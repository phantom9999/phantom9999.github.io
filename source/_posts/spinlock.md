---
title: spinlock
categories: essay
comments: false
date: 2018-08-05 18:43:55
updated: 2018-08-05 18:43:55
tags: [ spin lock, 自旋锁, cpp, boost ]
keywords: c++, boost, 自旋锁, spin lock
description: 本文介绍自旋锁的使用
---

# 简介
本文将介绍自旋锁的原理, 并封装linux提供的自旋锁, 最后介绍boost提供的自旋锁.

# 背景
自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分（对于单处理器来说，防止中断处理中的并发可简单采用关闭中断的方式，即在标志寄存器中关闭/打开中断标志位，不需要自旋锁）。

何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。

跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题：
死锁。试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入死循环。
过多占用cpu资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会。
由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。
上面简要介绍了自旋锁的基本原理，以下将给出具体的例子，进一步阐释自旋锁在实际系统中的应用。上面我们已经讲过自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，下面我们就以SMP为例，来说明为什么要使用自旋锁，以及自旋锁实现的基本算法。

通俗的讲, 自旋锁是一种不放弃CPU资源的锁.



# 自旋锁使用
# 封装
```
class SpinLock {
public:
    void lock() {
        pthread_spin_lock(&spinlock_);
    }

    void unlock() {
        pthread_spin_unlock(&spinlock_);
    }

private:
    pthread_spinlock_t spinlock_;
};

class SpinLockGuard {
public:
    explicit SpinLockGuard(SpinLock &spinlock): spinlock_(spinlock) {
        spinlock_.lock();
    }

    ~SpinLockGuard() {
        spinlock_.unlock();
    }

};


SpinLock lock;
{
    SpinLockGuard guard(lock);
}
```





# boost版本
boost中实现了自旋锁功能, 但是没有显示提供, 自旋锁的位置在<code>boost/smarty_ptr/detail/spinlock.hpp</code>
lockguard在<boost/thread/thread_guard.hpp>.

使用方法如下:

```
using SpinLock = boost::detail::spinlock;
using SpinLockGuard = boost::lock_guard<SpinLock>;


SpinLock lock;
{
    SpinLockGuard guard(lock);
}



```





