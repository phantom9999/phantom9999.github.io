<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入浅出triton-inference-server</title>
      <link href="/posts/11fad353.html"/>
      <url>/posts/11fad353.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>triton-inference-server是英伟达开源的推理服务，支持多种推理引擎、支持多模型多版本，同时支持自定义后端，方便用户拓展。</p><h1 id="环境搭建及使用"><a href="#环境搭建及使用" class="headerlink" title="环境搭建及使用"></a>环境搭建及使用</h1><h2 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h2><p>triton是使用cmake构建的服务，本身有多个代码库组成：</p><ul><li>core 服务核心代码</li><li>common 公共使用的工具(proto)</li><li>backend 推理引擎接口</li><li>server 服务代码</li><li>third_party 一些魔改后的三方库</li><li>xxx_backend 使用backend接口封装的各个推理引擎</li></ul><p>server这个二进制会静态链接core、common、backend的代码，形如xxx_backend都是以动态链接库的形式。</p><p>server提供了build.py脚本，用于构建，主要的内容包括，根据入参生成编译脚本和对应dockerfile，然后启动镜像进行编译。<br>这里的参数包括，需要的引擎、需要开启的功能等。</p><p>执行<code>./build.py -v –enable-all –dryrun</code>，只生成脚本，并不实际执行，生成的文件包括:</p><ul><li>Build/cmake_build 基于cmake构建组件的脚本</li><li>Build/docker_build 构建docker镜像的脚本</li><li>Build/Dockerfile 运行镜像</li><li>Build/Dockerfile.buildbase 构建镜像</li><li>Build/Dckerfile.cibase 流水线镜像</li></ul><p>例如cpu版本的构建命令如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">./build.py -v \</span><br><span class="line">--enable-logging \</span><br><span class="line">--enable-stats \</span><br><span class="line">--enable-metrics \</span><br><span class="line">--enable-tracing  \</span><br><span class="line"><span class="attribute">--backend</span>=identity \</span><br><span class="line"><span class="attribute">--backend</span>=repeat \</span><br><span class="line"><span class="attribute">--backend</span>=ensemble \</span><br><span class="line"><span class="attribute">--backend</span>=square \</span><br><span class="line"><span class="attribute">--backend</span>=tensorflow2 \</span><br><span class="line"><span class="attribute">--backend</span>=onnxruntime \</span><br><span class="line"><span class="attribute">--backend</span>=openvino \</span><br><span class="line"><span class="attribute">--backend</span>=pytorch \</span><br><span class="line"><span class="attribute">--backend</span>=python \</span><br><span class="line"><span class="attribute">--repoagent</span>=checksum \</span><br><span class="line"><span class="attribute">--endpoint</span>=grpc \</span><br><span class="line"><span class="attribute">--endpoint</span>=http \</span><br><span class="line"><span class="attribute">--extra-backend-cmake-arg</span>=tensorflow:TRITON_TENSORFLOW_INSTALL_EXTRA_DEPS=ON</span><br></pre></td></tr></table></figure><p>gpu版本的构建命令如下:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./build.py</span> -v <span class="params">--enable-logging</span> <span class="params">--enable-stats</span> <span class="params">--enable-metrics</span> <span class="params">--enable-gpu-metrics</span> \</span><br><span class="line"><span class="params">--enable-tracing</span> <span class="params">--enable-nvtx</span> <span class="params">--enable-gpu</span> <span class="params">--backend=tensorflow1</span> <span class="params">--backend=tensorflow2</span> \</span><br><span class="line"><span class="params">--repoagent=checksum</span> <span class="params">--endpoint=grpc</span> <span class="params">--endpoint=http</span></span><br></pre></td></tr></table></figure><p>事实上，如果要在内部维护triton，直接使用build.py是远远不够的，服务需要一定的改造来适应现有的基础设施。<br>通常我们需要这些dockerfile文件:</p><ul><li>base.Dockerfile 安装了各种三方库的镜像文件</li><li>build.Dockerfile 继承base.Dockerfile，并安装了common、core、backend库的镜像文件</li><li>xxx_backend.Dockerfile 继承build.Dockerfile，用于编译各个backend的镜像</li><li>server.Dockerfile 构建server，并融合各个backend的镜像文件</li></ul><p>除了镜像外，需要将common、core、backend、server的代码放到代码库中，根据不同的Dockerfile来编译不同的代码。<br>不同的backend放到不同的代码库中，一般还是会改一改的。</p><h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><p>todo: 服务配置说明</p><h2 id="模型配置"><a href="#模型配置" class="headerlink" title="模型配置"></a>模型配置</h2><p>triton支持多种文件存储，包括s3、as、gs和本地存储，通常能满足实际需要。</p><p>triton的模型目录要求如下:</p><ul><li>模型数据根目录<ul><li>A模型目录<ul><li>config.pbtxt文件</li><li>版本A1目录<ul><li>各种模型的数据文件</li></ul></li><li>版本A2目录</li><li>…</li></ul></li><li>B模型目录<ul><li>config.pbtxt文件</li><li>版本B1目录</li><li>版本B2目录</li><li>…</li></ul></li></ul></li></ul><p>config.pbtxt是模型的配置文件。<br>在triton中一个模型可以拥有多个版本，但是输入输出都是固定的，并且使用的引擎也是固定的，即一个模型可以有多个版本，一个引擎可以有多个模型。</p><p>模型的具体配置可以在<a href="https://docs.nvidia.com/deeplearning/triton-inference-server/user-guide/docs/user_guide/model_repository.html" target="_blank" rel="noopener">triton的model_repository文档里看到</a>，<br>这里简单介绍一下。</p><p>模型的配置分为必填配置和选填配置两种：</p><ul><li>必填配置<ul><li>模型名、推理引擎、引擎库路径</li><li>响应模式(一对一还是一对多)</li><li>batch容量</li><li>模型的输入输出定义</li></ul></li><li>选填配置<ul><li>版本控制策略</li><li>模型实例分组策略</li><li>调度器策略</li><li>优化策略</li><li>预热配置</li></ul></li></ul><p>todo: 展开介绍</p><h2 id="模型管理"><a href="#模型管理" class="headerlink" title="模型管理"></a>模型管理</h2><p>通常公司会有一个模型管理平台，triton模型加载机制需要与这个平台适配，从而能够更好的管理。<br>当服务的实例较多时，直接从s3、as、gs或者hdfs上获取模型的方式，可能不太适用。<br>毕竟这些对象存储的作用是存储数据，而不是支撑大流量读取。<br>这时，需要基于p2p搭建一套模型订阅推送的机制，保障模型正常发布的同时，减轻集中存储的压力。</p><p>要实现这个功能，通常每个Node上部署一个p2p实例pod，同时进行目录挂载，将模型目录分别挂载到triton的pod和p2p的pod。</p><p>triton在服务启动时根据配置向平台注册，并获取到需要的模型机器版本。<br>然后triton与p2p的pod交互，让其拉去相应的模型数据，并获得拉去任务的状态，进行模型加载。<br>并且定时上传心跳及从平台获取模型的最新版本情况，以此决定是否需要拉去最新的版本。</p><p>p2p的服务可以基于dragonfly或者bbts改造，模型平台也需要提供获取模型版本信息的接口。<br>triton扫目录获取模型版本的逻辑也需要改成从模型平台接口获取。</p><h1 id="自定义后端"><a href="#自定义后端" class="headerlink" title="自定义后端"></a>自定义后端</h1><p>todo:</p><h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>todo:</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> serving </tag>
            
            <tag> triton </tag>
            
            <tag> tensorRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apollo c++客户端</title>
      <link href="/posts/bd7510e0.html"/>
      <url>/posts/bd7510e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/apolloconfig/apollo" target="_blank" rel="noopener">apollo</a>是携程开源的一款较为成熟的远程配置系统。<br>通过这个远程配置，用户可以在界面上配置参数，然后让参数自动同步到服务上，减少中间不必要的CICD流程。<br>目前apollo提供了java和.net的客户端，但没有c++版本的，本文将设计并实现一款c++语言版本的客户端。<br>对于直接使用的用户，可以直接跳到“使用案例”环节。</p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>配置文件解析一直是c++同学的痛，每次添加配置就需要一段额外的代码解析。<br>而解析的步骤必须要先判断key在不在，然后判断value的类型，接着把value取出来。<br>如果value比较深，就要解析好几回，费时费力不说，中间环节还不能少，一少就容易出coredump(没错，就是rapidjson)。<br>像某些语言就不一样了，直接一键反序列化(比如jackson)，还是很方便的。<br>一套方便的反序列化方式，还是很有必要的。</p><p>引入远程配置系统之前，通常配置文件是本地配置，分为一次性加载和热加载两种，前者在服务启动时读取并解析；后者需要开相应的线程区侦测文件变化，文件发生变化后，重新加载解析，并替换内存中的数据。<br>接入远程配置之后，客户端需要知道配置的变更，并同步下来并替换内存中的数据。<br>目前apollo并没有中间者，无法从中间者订阅更新，需要客户端根据已有的接口，实现一套更新机制。</p><p>本地配置加载失败通常是配置文件解析失败，或者磁盘坏了加载不了。前者只要流水线完善基本可以避免，后者虽然避免不了，但是发生的概率极低，并且出现问题的实例也不会很多。<br>引入远程配置系统后，远程配置的服务稳定性影响着接入远程配置的服务的稳定性。<br>虽然这类基础服务的服务稳定性较高，但是没有到达100%，当接入实例较多时，一次重启总会出现几个失败的实例。<br>一套有效的容错机制还是有必要的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="反序列化问题"><a href="#反序列化问题" class="headerlink" title="反序列化问题"></a>反序列化问题</h3><p>目前apollo支持properties、json、yaml、yml、xml、txt等格式，其中json、yaml、yml、xml、txt不支持分级发布。<br>properties支持kv结构，value不支持复杂结构。<br>目前c++中能支持“一键反序列化”的就数protobuf和thrift了，本文将使用protobuf作为反序列化工具。</p><p>上面提到的哪几种不支持分级发布的格式，可以认为是兼容格式，应该逐渐迁移到properties中。<br>properties各种中的value本身是字符串，可以填充json，然后使用protobuf进行反序列化。<br>使用的时候根据key获取对应Message数据，减少解析的环节。<br>这种方式一方面能对配置进行分组管理，避免配置较多时出现杂乱的情况；<br>另一方面，远程配置客户端通常是不保障同一个业务请求中多次调用获取同一个值的。<br>如果配置基础类型，通常在一个业务请求中会使用多次，这时如果每次的值不一样，可能导致异常的情况，并且还不好定位。<br>综上，本文的客户端强制要求value是json格式，然后使用对应的Message进行反序列化。</p><h3 id="更新问题"><a href="#更新问题" class="headerlink" title="更新问题"></a>更新问题</h3><p>apollo提供了三套接口，带缓存接口、不带缓存接口、long poll接口。</p><p>“带缓存接口”每次请求都会返回相应的数据，需要用户自行判断数据是否更新。<br>一般这个接口是固定事件间隔轮询，查询一次就反序列化数据，并更新内存数据，实际也没啥大的问题，除了看上去比较low之外。</p><p>“不带缓存接口”需要用户每次请求带上releaseKey，然后如果配置更新则返回数据和新的releaseKey，否则返回304表示配置没更新。<br>通过这个接口可以发现数据是否已经更新，方便替换。但是这个接口不知道性能怎么样。</p><p>“long poll”接口，需要客户端请求服务，然后服务把接口挂起，直到配置有更新，才会有相应。<br>这个需要客户端有特殊处理，不然超过60s，自动超时。</p><p>权衡之后，选择第二种“不带缓存接口”，客户端需要额外记录每个namespace的releaseKey，方便后续更新。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> apollo </tag>
            
            <tag> 远程配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bthread_in_deep</title>
      <link href="/posts/e4420122.html"/>
      <url>/posts/e4420122.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生产环境使用boost::fiber</title>
      <link href="/posts/589c6abb.html"/>
      <url>/posts/589c6abb.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>boost::fiber是一类用户级线程，也就是纤程。其提供的例子与实际生产环境相距较远，本文将对其进行一定的改造，将其能够投入到生产环境。<br>同时由于纤程是具有传染性的，使用纤程的代码里也全部要用纤程封装，本文将对一些组件进行简单封装。</p><h1 id="fiber封装"><a href="#fiber封装" class="headerlink" title="fiber封装"></a>fiber封装</h1><p>boost::fiber支持设置pthread和fiber的比例是1:n还是m:n，同时也支持设置调度方式是随机调度还是抢占调度。<br>本文中选择使用抢占式调度，并且是m:n的比例，这种选择适用面更加广。<br>既然pthread和fiber比例是m:n，那么这个m一般等于逻辑核数量，也就是需要设置fiber调度的线程控制在大小为固定的线程池中。fiber中抢占式调度方式也要求固定的线程池数量，外部前程加入时，可能会影响抢占式调度，即不能在外部线程中调用fiber，不然这个线程就加入到了fiber调度的pthread中了。</p><p>这时，需要一个设置一个队列，外部线程往这个队列中添加任务；内部线程池从队列中取任务，同时触发fiber，在fiber中可以继续触发fiber。触发队列、内部队列、工作线程、外部线程的关系如下图所示:</p><p><img src="/images/fiber_in_use.jpg" alt="图片"></p><p>运行逻辑被装箱到一个任务中，然后被添加到任务队列，这一步利用模板和上转型实现，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IFiberTask</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  IFiberTask() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~IFiberTask() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  IFiberTask(<span class="keyword">const</span> IFiberTask&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">  IFiberTask&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> IFiberTask&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">  IFiberTask(IFiberTask&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  IFiberTask&amp; <span class="keyword">operator</span>=(IFiberTask&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">atomic_size_t</span> fibers_size &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberTask</span>:</span> <span class="keyword">public</span> IFiberTask &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FiberTask</span><span class="params">(Func&amp;&amp; func)</span> :func_</span>&#123;<span class="built_in">std</span>::<span class="built_in">move</span>(func)&#125; &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ~FiberTask() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">  FiberTask(<span class="keyword">const</span> FiberTask&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">  FiberTask&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> FiberTask&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">  FiberTask(FiberTask&amp;&amp; other)  <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  FiberTask&amp; <span class="keyword">operator</span>=(FiberTask&amp;&amp; other)  <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    fibers_size.fetch_add(<span class="number">1</span>);</span><br><span class="line">    func_();</span><br><span class="line">    fibers_size.fetch_sub(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Func func_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>IFiberTask是任务基类，不可拷贝；FiberTask是模板类，成员变量func_存储算子。使用IFiberTask类指针指向特化后的FiberTask对象，这时就实现的装箱操作，调用execute时，实际调用了子类的execute，触发封装的func_对象。</p><p>外部队列基于<code>boost::fibers::buffered_channel</code>实现，这是一个支持并发的队列，队列的元素类型为<code>std::tuple&lt;boost::fibers::launch, std::unique_ptr<ifibertask>&gt;</ifibertask></code>，其中tuple第一元素存储任务的触发形式，进入队列还是立即触发。</p><p>接着是任务装箱，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Submit</span><span class="params">(boost::fibers::launch launch_policy, Func&amp;&amp; func, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 捕获lambda极其参数</span></span><br><span class="line">  <span class="keyword">auto</span> capture = [func = <span class="built_in">std</span>::forward&lt;Func&gt;(func),</span><br><span class="line">      args = <span class="built_in">std</span>::make_tuple(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::apply(<span class="built_in">std</span>::<span class="built_in">move</span>(func), <span class="built_in">std</span>::<span class="built_in">move</span>(args));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任务的返回值类型</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">task_result_t</span> = <span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;<span class="keyword">decltype</span>(capture)&gt;;</span><br><span class="line">  <span class="comment">// 该任务packaged_task的</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">packaged_task_t</span> = boost::fibers::packaged_task&lt;<span class="keyword">task_result_t</span>()&gt;;</span><br><span class="line">  <span class="comment">// 创建任务对象</span></span><br><span class="line">  <span class="keyword">packaged_task_t</span> task &#123;<span class="built_in">std</span>::<span class="built_in">move</span>(capture)&#125;;</span><br><span class="line">  <span class="comment">// 装箱到FiberTask中</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">task_t</span> = fiber::FiberTask&lt;<span class="keyword">packaged_task_t</span>&gt;;</span><br><span class="line">  <span class="comment">// 获取packaged_task的future</span></span><br><span class="line">  <span class="keyword">auto</span> result_future = task.get_future();</span><br><span class="line">  <span class="comment">// 添加到buffered_channel中</span></span><br><span class="line">  <span class="keyword">auto</span> status = work_queue_.push(</span><br><span class="line">      <span class="built_in">std</span>::make_tuple(launch_policy, <span class="built_in">std</span>::make_unique&lt;<span class="keyword">task_t</span>&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(task))));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status != boost::fibers::channel_op_status::success) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(result_future)&gt;&gt; &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_optional(<span class="built_in">std</span>::<span class="built_in">move</span>(result_future));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，先捕获lambda表达式及其参数，获取返回值类型并添加到packaged_task中，然后装箱到FiberTask中，使用packaged_task获取future并返回，FiberTask对象添加到队列中，使用IFiberTask的指针指向这个对象，实现装箱操作。</p><p>接着是内部任务触发的逻辑，首先创建一个线程池，每个线程注册调度器，接着从队列中获取任务，触发fiber。<br>工作线程的执行函数如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册调度算法为抢占式调度</span></span><br><span class="line">boost::fibers::use_scheduling_algorithm&lt;boost::fibers::algo::work_stealing&gt;(threads_size_, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 创建task类型</span></span><br><span class="line"><span class="keyword">auto</span> task_tuple = <span class="keyword">typename</span> <span class="keyword">decltype</span>(work_queue_)::value_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列中获取任务</span></span><br><span class="line"><span class="keyword">while</span>(boost::fibers::channel_op_status::success == work_queue_.pop(task_tuple)) &#123;</span><br><span class="line">  <span class="comment">// 解包</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; [launch_policy, task_to_run] = task_tuple;</span><br><span class="line">  <span class="comment">// 触发 fiber并detach</span></span><br><span class="line">  boost::fibers::fiber(launch_policy, [task = <span class="built_in">std</span>::<span class="built_in">move</span>(task_to_run)]() &#123;</span><br><span class="line">    task-&gt;execute();</span><br><span class="line">  &#125;).<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抢占式调度在注册时需要指定线程池大小，这时不能在外部线程中调用fiber，因为调用fiber的时候会把该线程添加到fiber调度的线程中，也就调整了fiber的worker线程数量。</p><p>以上代码实现了fiber触发器、任务队列、工作线程池等逻辑。<br>理论上可以创建多个fiber调度组件对象，每个组件根据自己的需要设置资源情况。<br>但实际应用中，还是建议使用一个全局调度组件，因为当A调度器中的任务依赖B调度器的任务的同时，就会出现阻塞工作线程，影响实际性能。</p><p>下面封装一个全局调度器，提供递交任务的接口和结束调度的接口:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultPool</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span>* <span class="title">Pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> fiber::FiberPool <span class="title">pool</span><span class="params">(<span class="built_in">size</span>, <span class="built_in">size</span>*<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;pool;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">SubmitJob</span><span class="params">(boost::fibers::launch launch_policy, Func &amp;&amp;func, Args &amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pool()-&gt;Submit(launch_policy, <span class="built_in">std</span>::forward&lt;Func&gt;(func), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">SubmitJob</span><span class="params">(Func &amp;&amp;func, Args &amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pool()-&gt;Submit(<span class="built_in">std</span>::forward&lt;Func&gt;(func), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pool()-&gt;CloseQueue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  DefaultPool() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="其他组件封装"><a href="#其他组件封装" class="headerlink" title="其他组件封装"></a>其他组件封装</h1><p>上面对boost::fiber进行封装，得到一个能投入生产环境的调度器。<br>但是仅仅是这些是不够的，毕竟对于生产环境中的服务而言，外部服务、中间件的依赖是不能少的。<br>纤程是具有传染性的，对于外部组件提供的sdk，发送请求并进行同步等待会阻塞纤程对应的工作线程，影响整套机制。<br>为此，需要对现有的组件进行封装，对于同步接口，需要使用线程池配合fiber::promise；对于异步接口，可以改造成fiber::promise、future机制。下面介绍几种常用组件的fiber封装。</p><h2 id="redis客户端封装"><a href="#redis客户端封装" class="headerlink" title="redis客户端封装"></a>redis客户端封装</h2><p>同步接口加线程池的方式将同步接口改造成异步接口的方案，存在较大的安全隐患。<br>线程池的容量不可控，当流量突然增加时，需要大量线程去等待，从而耗尽线程池资源，造成任务大量积压，服务崩溃。<br>而扩大线程池数量，又消耗了大量的资源。</p><p>综上，对于fiber化封装，还是建议采用异步接口。hiredis库支持异步接口，redis_plus_plus库对hiredis进行了c++封装，同时也提供了异步接口，本节将面向这个接口进行改造。</p><p>redis提供了挺多的接口，这里只对del、get、set三个接口做个示范:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">using</span> Promise = boost::fibers::promise&lt;Type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">using</span> Future = boost::fibers::<span class="built_in">future</span>&lt;Type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">Future&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt; <span class="title">Del</span><span class="params">(<span class="keyword">const</span> StringView &amp;key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> promise = <span class="built_in">std</span>::make_unique&lt;Promise&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt;&gt;();</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">future</span> = promise-&gt;get_future();</span><br><span class="line">  <span class="comment">// 在回调函数中对promise赋值</span></span><br><span class="line">  redis_.del(key, [promise =promise.<span class="built_in">release</span>()](sw::redis::Future&lt;<span class="keyword">long</span> <span class="keyword">long</span> &gt; &amp;&amp;fut) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      promise-&gt;set_value(fut.<span class="built_in">get</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      promise-&gt;set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> promise;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">future</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Future&lt;OptionalString&gt; <span class="title">Get</span><span class="params">(<span class="keyword">const</span> StringView &amp;key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> promise = <span class="built_in">std</span>::make_unique&lt;Promise&lt;OptionalString&gt;&gt;();</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">future</span> = promise-&gt;get_future();</span><br><span class="line">  <span class="comment">// 在回调函数中对promise赋值</span></span><br><span class="line">  redis_.<span class="built_in">get</span>(key, [promise = promise.<span class="built_in">release</span>()](sw::redis::Future&lt;OptionalString&gt; &amp;&amp;fut) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      promise-&gt;set_value(fut.<span class="built_in">get</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      promise-&gt;set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> promise;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">future</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Future&lt;<span class="keyword">bool</span>&gt; <span class="title">Set</span><span class="params">(<span class="keyword">const</span> StringView &amp;key, <span class="keyword">const</span> StringView &amp;val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> promise = <span class="built_in">std</span>::make_unique&lt;Promise&lt;<span class="keyword">bool</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">future</span> = promise-&gt;get_future();</span><br><span class="line">  <span class="comment">// 在回调函数中对promise赋值</span></span><br><span class="line">  redis_.<span class="built_in">set</span>(key, val, [promise = promise.<span class="built_in">release</span>()](sw::redis::Future&lt;<span class="keyword">bool</span>&gt; &amp;&amp;fut) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      promise-&gt;set_value(fut.<span class="built_in">get</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      promise-&gt;set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> promise;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">future</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，redis_plus_plus对每个回调函数通过模板进行判断，因此无法使用mutable+移动捕获promise，只能使用指针赋值的方式实现。redis_plus_plus在1.3.6以后的版本才有回调函数机制，之前的版本不支持。<br>上面原理是，创建fiber的promise和future，然后让redis的回调函数中捕获promise，并在promise中对数据进行赋值。而外部使用fiber的future进行等待，并不会阻塞工作线程。</p><h2 id="grpc客户端封装"><a href="#grpc客户端封装" class="headerlink" title="grpc客户端封装"></a>grpc客户端封装</h2><p>跟上面的redis客户端类似，这里也建议对grpc的异步客户端进行改造，支持fiber的promise、future机制。<br>grpc的异步客户端需要牵扯到<code>grpc::CompletionQueue</code>，里面实现了一套poll engine，需要绑定一个线程去进行epoll_wait操作。首先定义一个GrpcClient类，包含四个成员变量、两个成员函数，如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrpcClient</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">GrpcClient</span><span class="params">(<span class="keyword">const</span> ClientOption&amp; option)</span></span>;</span><br><span class="line">  ~GrpcClient();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对外提供的接口</span></span><br><span class="line">  <span class="function">Future&lt;meta::HelloResponse&gt; <span class="title">Call</span><span class="params">(<span class="keyword">const</span> meta::HelloRequest&amp; request)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// worker线程执行的逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;grpc::CompletionQueue&gt; completion_queue_;</span><br><span class="line">  <span class="built_in">std</span>::thread worker_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;grpc::Channel&gt; channel_;</span><br><span class="line">  gpr_timespec timespec_&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>异步客户端分为三个部分逻辑，第一个是请求发送(Call函数)，第二个是io线程批量处理，第三个是外部等待Future。<br>为了能够让io线程里给Promise进行赋值，需要Call函数中将Promise及其相关上下文传递到io线程中，这里定义一个上下文结构体:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CallData</span> &#123;</span></span><br><span class="line">  grpc::ClientContext context;          <span class="comment">// grpc上下文</span></span><br><span class="line">  Promise&lt;meta::HelloResponse&gt; promise; <span class="comment">// Promise对象</span></span><br><span class="line">  grpc::Status status;                  <span class="comment">// grpc调用状态</span></span><br><span class="line">  meta::HelloResponse response;         <span class="comment">// 相应包</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Call函数中的逻辑如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建上下文对象</span></span><br><span class="line"><span class="keyword">auto</span> data = <span class="keyword">new</span> CallData;</span><br><span class="line"><span class="comment">// 设置超时时间</span></span><br><span class="line">data-&gt;context.set_deadline(timespec_);</span><br><span class="line"><span class="comment">// 创建桩</span></span><br><span class="line">meta::<span class="function">HelloService::Stub <span class="title">stub</span><span class="params">(channel_)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">future</span> = data-&gt;promise.get_future();</span><br><span class="line"><span class="comment">// 异步调用，添加到完成队列中</span></span><br><span class="line"><span class="keyword">auto</span> rpc = stub.Asynchello(&amp;data-&gt;context, request, completion_queue_.<span class="built_in">get</span>());</span><br><span class="line"><span class="comment">// 绑定response、status，并将上下文对象作为tag传下去</span></span><br><span class="line">rpc-&gt;Finish(&amp;data-&gt;response, &amp;data-&gt;status, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(data));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">future</span>;</span><br></pre></td></tr></table></figure><p>data对象在该函数中创建，在Work函数中释放，不存在内存泄漏问题。<br>grpc的异步稍微有点麻烦，发送之后，还要绑定数据。<br>接着是Work线程中的逻辑了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CallData* data = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 获取状态完毕的数据</span></span><br><span class="line"><span class="keyword">while</span> (completion_queue_-&gt;Next((<span class="keyword">void</span>**)&amp;data, &amp;ok)) &#123;</span><br><span class="line">  <span class="comment">// 判断队列是否已经结束</span></span><br><span class="line">  <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果grpc状态ok，则赋值</span></span><br><span class="line">  <span class="keyword">if</span> (data-&gt;status.ok()) &#123;</span><br><span class="line">    data-&gt;promise.set_value(<span class="built_in">std</span>::<span class="built_in">move</span>(data-&gt;response));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则设置异常</span></span><br><span class="line">    data-&gt;promise.set_exception(<span class="built_in">std</span>::make_exception_ptr(</span><br><span class="line">        <span class="built_in">std</span>::runtime_error(data-&gt;status.error_message())));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除数据</span></span><br><span class="line">  <span class="keyword">delete</span> data;</span><br><span class="line">  data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用完成队列的Next函数会阻塞，如果队列中存在状态达到最终状态的数据，则返回一条。从完成对于中取到的数据的顺序与入队顺序不同。</p><p>上面两个函数组合实现了Future获取和Promise赋值的操作，使得grpc客户端能在fiber中使用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/moneroexamples/fiberpool" target="_blank" rel="noopener">fiberpool代码</a></li><li><a href="https://github.com/phantom9999/mithril/tree/main/fiber_in_use" target="_blank" rel="noopener">生产环境使用fiber</a></li><li><a href="https://grpc.io/docs/languages/cpp/async/" target="_blank" rel="noopener">grpc异步客户端</a></li><li><a href="https://github.com/redis/hiredis" target="_blank" rel="noopener">hiredis</a></li><li><a href="https://github.com/sewenew/redis-plus-plus" target="_blank" rel="noopener">redis_plus_plus</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boost </tag>
            
            <tag> fiber </tag>
            
            <tag> 纤程 </tag>
            
            <tag> 协程 </tag>
            
            <tag> redis </tag>
            
            <tag> hiredis </tag>
            
            <tag> grpc </tag>
            
            <tag> redis_plus_plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>talk_concurrent_hashmap</title>
      <link href="/posts/637f3764.html"/>
      <url>/posts/637f3764.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>talk_concurrent_lru_cache</title>
      <link href="/posts/1c2ec8f7.html"/>
      <url>/posts/1c2ec8f7.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈一谈并发队列的实现</title>
      <link href="/posts/b971a5d0.html"/>
      <url>/posts/b971a5d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将谈一谈并发队列，讲解集中可手写的并发队列的实现方式，以及介绍几种开源并发队列的实现，当然都是c++版本的。<br>可手撸的并发队列实现起来相对简单，面试的时候可以撸一撸，简单生产环境也可以用一用；<br>当然，实际生产环境中，还是建议直接用高性能的开源实现。<br>可手撸的版本包括，单锁队列、双锁队列、原子队列；开源并发队列包括boost中的并发队列、tbb中的并发队列、folly中的并发队列、moodycamel中的并发队列。</p><h1 id="单锁队列实现"><a href="#单锁队列实现" class="headerlink" title="单锁队列实现"></a>单锁队列实现</h1><p>单锁队列是一种实现简单的并发队列，它通过一个锁控制入队和出队，通过两个条件变量分别控制队列空和队列满。<br>数据入队之前判断队列是否满，如果满了，则等待full条件变量；出队前判断队列是否为空，如果为空，则等待empty条件变量。当队列满时出队则唤醒full条件变量；当队列为空并入队时，唤醒empty条件变量。</p><p>代码如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BlockedQueue</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> : <span class="title">capacity_</span><span class="params">(capacity)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">TryPush</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Enqueue(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">TryPop</span><span class="params">(<span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!data_.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Dequeue(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">      full_.wait(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    Enqueue(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (data_.empty()) &#123;</span><br><span class="line">      empty_.wait(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    Dequeue(value);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    data_.push(value);</span><br><span class="line">    <span class="keyword">if</span> (data_.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">      empty_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dequeue</span><span class="params">(<span class="keyword">int</span>* value)</span> </span>&#123;</span><br><span class="line">    *value = data_.front();</span><br><span class="line">    data_.pop();</span><br><span class="line">    <span class="keyword">if</span> (data_.<span class="built_in">size</span>() == capacity_ - <span class="number">1</span>) &#123;</span><br><span class="line">      full_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable full_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable empty_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; data_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> capacity_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的实现可以用单链表代替std::queue。<br>这种结构实现简单，临界区较小，可以在请求维度的数据中使用。</p><h1 id="双锁队列实现"><a href="#双锁队列实现" class="headerlink" title="双锁队列实现"></a>双锁队列实现</h1><p>双锁队列是另一种并发队列，使用两把锁分别控制入队和出队，性能相较于单锁的稍微强点。<br>双锁队列还包括两个条件变量，分别用于表示队列满和队列空；同时还拥有一个原子变量记录当前队列长度。<br>入队列时，先等待“非满”条件变量，然后入队列，如果队列没满，则唤醒“非满”变量。如果入队前队列是空的，入队后就要唤醒“非空”变量。<br>出队时，先等待“非空”条件变量，然后出队，如果队列还有数据，则唤醒“非空”变量。如果出队之前队列时非空的，则出队后唤醒“非满”变量。</p><p>代码如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node* next&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value = <span class="number">0</span>)</span>: <span class="title">val</span><span class="params">(value)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockQueue</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  LinkedBlockQueue(<span class="keyword">size_t</span> <span class="built_in">size</span>): capacity_(<span class="built_in">size</span>) &#123;</span><br><span class="line">    head_ = <span class="keyword">new</span> Node;</span><br><span class="line">    tail_ = head_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">TryPush</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count_.load() &gt;= capacity_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(push_mutex_)</span></span>;</span><br><span class="line">    Enqueue(value);</span><br><span class="line">    <span class="keyword">auto</span> current = count_.fetch_add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (current + <span class="number">1</span> &lt; capacity_) &#123;</span><br><span class="line">      not_full_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;</span><br><span class="line">      NotifyNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">TryPop</span><span class="params">(<span class="keyword">int</span>* value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count_.load() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(pop_mutex_)</span></span>;</span><br><span class="line">    Dequeue(value);</span><br><span class="line">    <span class="keyword">auto</span> current = count_.fetch_sub(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (current - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      not_empty_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == capacity_) &#123;</span><br><span class="line">      NotifyNotFull();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> current = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(push_mutex_)</span></span>;</span><br><span class="line">      not_full_.wait(lock, [&amp;]()&#123; <span class="keyword">return</span> count_.load() &lt; capacity_;&#125;);</span><br><span class="line">      Enqueue(value);</span><br><span class="line">      current = count_.fetch_add(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (current - <span class="number">1</span> &lt; capacity_) &#123;</span><br><span class="line">        not_full_.notify_one();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;</span><br><span class="line">      NotifyNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span>* value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> current = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(pop_mutex_)</span></span>;</span><br><span class="line">      not_empty_.wait(lock, [&amp;]()&#123; <span class="keyword">return</span> count_.load() &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">      Dequeue(value);</span><br><span class="line">      current = count_.fetch_sub(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (current &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        not_empty_.notify_one();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == capacity_) &#123;</span><br><span class="line">      NotifyNotFull();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    tail_-&gt;next = <span class="keyword">new</span> Node(value);</span><br><span class="line">    tail_ = tail_-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dequeue</span><span class="params">(<span class="keyword">int</span>* value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>* node = head_-&gt;next;</span><br><span class="line">    *value = node-&gt;val;</span><br><span class="line">    head_-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NotifyNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(push_mutex_)</span></span>;</span><br><span class="line">    not_full_.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NotifyNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock <span class="title">lock</span><span class="params">(pop_mutex_)</span></span>;</span><br><span class="line">    not_empty_.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Node* head_;</span><br><span class="line">  Node* tail_;</span><br><span class="line">  <span class="built_in">std</span>::mutex push_mutex_;</span><br><span class="line">  <span class="built_in">std</span>::mutex pop_mutex_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable not_full_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable not_empty_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> capacity_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">atomic_size_t</span> count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码稍微复杂一点，不过还是可以手工实现的。</p><h1 id="原子队列实现"><a href="#原子队列实现" class="headerlink" title="原子队列实现"></a>原子队列实现</h1><h1 id="boost中并发队列实现"><a href="#boost中并发队列实现" class="headerlink" title="boost中并发队列实现"></a>boost中并发队列实现</h1><h1 id="tbb中并发队列实现"><a href="#tbb中并发队列实现" class="headerlink" title="tbb中并发队列实现"></a>tbb中并发队列实现</h1><h1 id="folly中并发队列实现"><a href="#folly中并发队列实现" class="headerlink" title="folly中并发队列实现"></a>folly中并发队列实现</h1><h1 id="moodycamel中并发队列实现"><a href="#moodycamel中并发队列实现" class="headerlink" title="moodycamel中并发队列实现"></a>moodycamel中并发队列实现</h1><h1 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> folly </tag>
            
            <tag> boost </tag>
            
            <tag> queue </tag>
            
            <tag> concurrent </tag>
            
            <tag> tbb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>taskflow源码学习及使用</title>
      <link href="/posts/c1f760b3.html"/>
      <url>/posts/c1f760b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>taskflow是一个轻量级的图引擎，或者说是轻量级的tensorflow。<br>taskflow允许用户构建一个有向图，然后并行执行这个图，让图中相互依赖的节点串行执行，不依赖的节点并行执行。<br>这种方式既可视化了业务逻辑的依赖关系，又提升了整体执行的效率。<br>本文将先从源码的角度介绍taskflow库，然后基于taskflow开发一套企业级的策略引擎。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>taskflow库包括两个部分，图引擎和抢占式线程池。图引擎是taskflow的调度核心；抢占式线程池提升调度的性能。</p><h2 id="抢占式线程池"><a href="#抢占式线程池" class="headerlink" title="抢占式线程池"></a>抢占式线程池</h2><p>抢占式线程池(work stealing thread pool)是一种多队列线程池，有较好的性能。<br>抢占式线程池包含一个全局队列，线程池中每个线程拥有一个自己的队列。当某个线程执行完自己队列中的任务后，就会从其他队列或者全局队列获取任务进行执行。</p><p>类似线程池还有两种，分别是单队列线程池和多队列线程池。单队列线程池中只有一个全局队列，所有的线程从这个队列中获取任务并进行执行。这种线程池的线程不会出现忙碌不均的情况，但是由于任务来自全局队列，增加的任务竞争，一定程度上影响了性能。多队列线程池中包含多个队列，每个线程拥有一个自己的任务队列。线程池分配接口将任务随机分配给本地队列，然后对应的线程去处理对应任务。这种线程池由于使用本地队列，减少了任务竞争，一定程度上提升了性能，但是本地队列长度不均使得部分线程极其忙碌，部分线程一直空闲，整体资源利用率不高。抢占式线程池的出现，结合了两者有优势，弥补了两者的不足，既提升了性能，又提升了资源利用率。</p><p>接着来讲一下taskflow库中抢占式线程池的实现。<br>它的实现在<code>Executor</code>，其成员变量如下:</p><ul><li>_threads 线程组</li><li>_wsq 全局任务队列</li><li>_workers 线程上下文列表，类型是vector<worker></worker></li><li>_wids 线程号与上下文编号对应关系</li><li>_wsq 全局任务队列</li></ul><p><code>Executor</code>提供了一套run的接口，但是这些接口实际是将任务添加到队列中而已，线程组的线程会从全局队列中获取任务。</p><p><code>Worker</code>是线程的上下文，成员变量包括:</p><ul><li>_id 在_workers中的编号</li><li>_vtm 正在偷取的worker对应的在_workers中的编号</li><li>_rdgen 随机引擎，产生随机数</li><li>_wsq 本地任务队列</li></ul><p><code>Executor</code>中的线程又是如何配合的呢？？ 当<code>Executor</code>执行graph时，会创建一个Topology对象（可以理解为graph的Session），并添加到graph的Topology队列中。如果这个队列只包含一个元素，则将这个Topology中的root节点添加到全局任务队列中(_wsq)。root节点的定义是，这些节点没有依赖节点。添加_wsq之后，唤醒相应数量的线程，这些线程从_wsq取任务。每个节点执行完毕后，会更新该节点的下游节点的状态，如果下游节点没有其他依赖节点，则将该节点添加到本地任务队列中。接着该线程继续执行本地任务队列，直到本地任务队列为空。</p><p>这时，开始偷窃逻辑了。_vtm初始化为_id值，当_vtm等于_id时，从全局队列中获取任务；如果没获得任务，则使用_rdgen随机一个值赋值给_vtm，_vtm对应的Worker对象的本地队列中获取任务；如果依旧没有获取任务，则再次进行随机；重试多次后没有获取任务，并且全局任务队列中有任务，则从全局任务队列中获取；如果还没有任务，先将_vtm还原为_id，然后进行等待。</p><p>本地队列的任务只会由当前线程添加，所以，当本地队列没任务之后，只能从其他队列或者全局队列获取，执行完任务才有可能有新就绪的任务。</p><p><code>Executor</code>涉及两个组件，<code>Notifier</code>和<code>TaskQueue</code>。<br><code>TaskQueue</code>是基于原子指针实现的一写多读循环队列，它使用<code>TaskQueue::Array</code>实现了一个环，然后使用一个指向头的原子变量和一个指向尾的原子变量，控制队列的出队和入队。<br><code>Notifier</code>是从Eigen拷贝过来的，这里就不讲了。</p><h2 id="图引擎"><a href="#图引擎" class="headerlink" title="图引擎"></a>图引擎</h2><p>图引擎是taskflow库的核心，用户可以使用Taskflow对象创建一个有向图，然后使用Executor执行。<br>这个有向图执行时，相互依赖的节点串行执行，不相互依赖的节点并行执行。</p><p>图引擎主要涉及Taskflow、FlowBuilder、Topology、Graph、Node、Task类。<br>Node为图中的节点，记录与其他节点的依赖关系；Graph存储Node对象；FlowBuilder负责图构建；Taskflow为顶层图封装；<br>Topology用于基于图的一次执行。</p><p>使用Taskflow创建图时，Taskflow调用父类FlowBuilder的接口，将仿函数装入Node中，并将Node添加到Graph对象里，同时使用Task对象包裹Node类对象的指针。<br>用户使用Task的接口设置Node之间的依赖关系。</p><p>与tensorflow不同，Taskflow的Topology不记录每个节点的执行情况，依赖情况，仅仅记录本次执行的promise和需要等待多少个节点执行，而tensorflow的ExecutorState里记录了每个节点的依赖数量，并实时更新。</p><p>同一个graph多次执行时，每次执行生成一个Topology对象，添加到Taskflow对象的队列中。<br>graph被执行时会从这个队列里取第一个Topology，并初始化所有Node的依赖计数器。每个节点执行完毕，就会更新其下游节点的计数器。如果下游节点已经就绪，则添加任务队列中。</p><p>Node节点包含了大量的结构：</p><ul><li>_name 节点名</li><li>_data 数据指针</li><li>_handle 节点类型句柄，包括静态任务、动态任务等等</li><li>_successors 下游节点列表</li><li>_dependents 上有节点列表</li><li>_topology 当前执行的session</li><li>_parent 父图节点</li><li>_state 执行状态</li><li>_join_counter 依赖节点数量</li><li>_semaphores 信号量</li></ul><p>图执行时，会将依赖(_dependents)的节点添加就绪队列中；<br>当一个节点执行完毕，则会更新下游节点(_dependents)的依赖节点数量(_join_counter)。<br>如果某个节点的_join_counter为0，表示它依赖的节点都已经执行完毕，则达到就绪状态，可以开始执行了。</p><p>每次取出Topology对象时，都会对每个节点的_join_counter进行初始化，方便后续执行。<br>也由于这个设计，一个图(Taskflow对象)可以并行被调用多次，但是图的每次执行都是串行的，每次被调用就产生一个Topology，只有前一个Topology执行完毕，才会执行后一个Topology。</p><p>为了保障一个图能被并行执行，需要根据这个图创建多个Taskflow对象，每次执行使用不同的对象。<br>这种方式带来的问题，要么每次执行前构建一个图，然后执行；要么创建缓存队列，执行时从队列里取，执行完毕后再放回队列中，如果不够用则动态创建。<br>相对来说，还是后者性能更高一些。当然tensorflow就没有这个问题了，每次执行时创建一个executionStatus就行了。</p><p>Node的仿函数存储在handle_对象中，通过仿函数的参数提取机制，将仿函数装箱到对应的结构中，然后将这个对象塞到variant。调用时判断其类型，设置入参。</p><h1 id="策略引擎"><a href="#策略引擎" class="headerlink" title="策略引擎"></a>策略引擎</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> taskflow </tag>
            
            <tag> graph engine </tag>
            
            <tag> strategy server </tag>
            
            <tag> dag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow模型数据解析</title>
      <link href="/posts/e1fa92aa.html"/>
      <url>/posts/e1fa92aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将介绍一下tensorflow的saved model数据的结构。</p><h1 id="模型文件"><a href="#模型文件" class="headerlink" title="模型文件"></a>模型文件</h1><p>tensorflow的saved model的目录结构如下:</p><ul><li>saved_model.pb 模型描述文件，pb二进制; 也可以是pbtxt后缀的文本文件</li><li>variables 模型参数数据目录<ul><li>variables.index 模型索引文件</li><li>variables.data-00000-of-00001 模型数据文件</li></ul></li><li>assets.extra<ul><li>tf_serving_warmup_requests 预热请求包，pb二进制文件</li></ul></li></ul><h1 id="模型加载流程"><a href="#模型加载流程" class="headerlink" title="模型加载流程"></a>模型加载流程</h1><p>参考上一篇文章中模型加载流程，模型加载时会调用LoadSavedModel函数用于加载模型。<br>这个函数调用LoadSavedModelInternal进行实际的加载操作:</p><ul><li>ReadMetaGraphDefFromSavedModel</li><li>LoadMetaGraphIntoSession</li><li>GetAssetFileDefs</li><li>RunRestore</li></ul><p>其中RunRestore函数中加载了参数数据，具体操作是执行该模型图中<code>bundle-&gt;meta_graph_def.saver_def().restore_op_name()</code>算子。</p><p>以half_plus_two_pbtxt为例，文件在tensorflow-1.15.0/tensorflow/cc/saved_model/testdata/half_plus_two_pbtxt/00000123/saved_model.pbtxt。<br>图中saver_def内容如下:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">saver_def </span>&#123;</span><br><span class="line"><span class="symbol">    filename_tensor_name:</span> <span class="string">"save/Const:0"</span></span><br><span class="line"><span class="symbol">    save_tensor_name:</span> <span class="string">"save/Identity:0"</span></span><br><span class="line"><span class="symbol">    restore_op_name:</span> <span class="string">"save/restore_all"</span></span><br><span class="line"><span class="symbol">    max_to_keep:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">    sharded:</span> true</span><br><span class="line"><span class="symbol">    keep_checkpoint_every_n_hours:</span> <span class="number">10000.0</span></span><br><span class="line"><span class="symbol">    version:</span> V2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载时需要执行”save/restore_all”算子, 由于依赖关系，实际上需要执行多个算子。<br>使用netron工具打开图描述，可以看到如下:</p><p><img src="/images/tf_netron.png" alt></p><p>它本身是个NoOp，主要依赖了RestoreV2算子和Assign算子。其中，RestoreV2算子实际加载了数据。<br>RestoreV2算子代码在tensorflow-1.15.0/tensorflow/core/kernels/save_restore_v2_ops.cc中。</p><p>整个流程包括:</p><ol><li>查询index文件的index段, 获取data块的信息</li><li>查询index文件的data段中的块,获得数据段信息</li><li>根据数据段信息,从data文件中截取数据.</li></ol><p>整个调用栈:</p><ul><li>RestoreV2::Compute 数据加载<ul><li>ValidateInputs 校验</li><li>RestoreTensorsV2 加载数据<ul><li>校验tensor_name的类型</li><li>遍历拆分队列(维度多的多线程跑，维度小的单线程跑)</li><li>RestoreOp::run 加载一个tensor name<ul><li>BundleReader::LookupTensorShape 获取形状</li><li>BundleReader::Lookup 没设置shape_and_slice</li><li>BundleReader::LookupSlice 有设置 shape_and_slice</li></ul></li></ul></li></ul></li></ul><p>RestoreOp::run运行时会创建BunleReader对象，这里涉及到一个初始化过程:</p><ul><li>解析footer</li><li>加载index文件的index段</li><li>读取header数据</li></ul><p>header的结构为BundleHeaderProto, 定义如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">BundleHeaderProto</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Number of data files in the bundle.</span></span><br><span class="line">    <span class="built_in">int32</span> num_shards = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An enum indicating the endianness of the platform that produced this</span></span><br><span class="line">    <span class="comment">// bundle.  A bundle can only be read by a platform with matching endianness.</span></span><br><span class="line">    <span class="comment">// Defaults to LITTLE, as most modern platforms are little-endian.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Affects the binary tensor data bytes only, not the metadata in protobufs.</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Endianness</span> </span>&#123;</span><br><span class="line">        LITTLE = <span class="number">0</span>;</span><br><span class="line">        BIG = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Endianness endianness = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Versioning of the tensor bundle format.</span></span><br><span class="line">    VersionDef version = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>header数据的key为空字符串，header中保存了分片数量，即data文件的数量。</p><p>BundleReader::Lookup的逻辑如下:</p><ul><li>BundleReader::GetBundleEntryProto 获取pb结构<ul><li>BundleReader::Seek<ul><li>TwoLevelIterator::Seek<ul><li>index_iter_-&gt;Seek 在index块中找到target</li><li>TwoLevelIterator::InitDataBlock 设置data_iter(没有就创建)</li><li>data_iter_-&gt;Seek 在data块中查找target</li><li>TwoLevelIterator::SkipEmptyDataBlocksForward</li></ul></li><li>ParseEntryProto 数据解析成BundleEntryProto结构</li></ul></li></ul></li><li>GetValue 根据BundleEntryProto结构中的信息，在data文件中读取数据</li><li>GetSliceValue 分段读取数据</li></ul><p>其中GetValue和GetSliceValue是两选一。<br>如果在调用BundleReader::GetBundleEntryProto拿到的BundleEntryProto结构中有slices结构,则表示数据进行分段了,<br>需要拼接一组新的key,然后依次调用BundleReader::GetBundleEntryProto和GetValue获取数据.</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Describes the metadata related to a checkpointed tensor.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">BundleEntryProto</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The tensor dtype and shape.</span></span><br><span class="line">    DataType dtype = <span class="number">1</span>;</span><br><span class="line">    TensorShapeProto shape = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// The binary content of the tensor lies in:</span></span><br><span class="line">    <span class="comment">//   File "shard_id": bytes [offset, offset + size).</span></span><br><span class="line">    <span class="built_in">int32</span> shard_id = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">int64</span> offset = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">int64</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The CRC32C checksum of the tensor bytes.</span></span><br><span class="line">    <span class="built_in">fixed32</span> crc32c = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iff present, this entry represents a partitioned tensor.  The previous</span></span><br><span class="line">    <span class="comment">// fields are interpreted as follows:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   "dtype", "shape": describe the full tensor.</span></span><br><span class="line">    <span class="comment">//   "shard_id", "offset", "size", "crc32c": all IGNORED.</span></span><br><span class="line">    <span class="comment">//      These information for each slice can be looked up in their own</span></span><br><span class="line">    <span class="comment">//      BundleEntryProto, keyed by each "slice_name".</span></span><br><span class="line">    <span class="keyword">repeated</span> TensorSliceProto slices = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当slices为非空时，表示当前数据采用了分段的方式，就会调用GetSliceValue。<br>这个函数中会根据tensor_name和slices数据，生成一个key列表，然后再走一边BundleReader::GetBundleEntryProto和<br>GetValue获取实际的数据。</p><h1 id="模型数据结构"><a href="#模型数据结构" class="headerlink" title="模型数据结构"></a>模型数据结构</h1><p>如果看过leveldb源码，就会发现，这两个代码的分段逻辑出奇的相似。<br>index文件分为index段、data段和footer段三部分。</p><p>footer段为48字节，末尾8个字节是magic字段用于校验，前面40字节中存储了四个vint64的数据，分别是：</p><ul><li>meta_index_handle<ul><li>offset</li><li>size</li></ul></li><li>index_handle<ul><li>offset</li><li>size</li></ul></li></ul><p>其中index_index_handle记录index段的位置。<br>index段包括三个部分,数据部分(index_handle.size大小)、压缩flags（1字节）、校验位(4字节)。<br>数据部分包括entry结构数组、偏移数组、entry数量(4字节)，其中entry数组和偏移数组长度相同。<br>entry结构数组中的entry是按照entry.key进行排序的，也就是一个有序数组。<br>根据key进行查询时，先二分在偏移数组中查找，比较阶段会读取entry中的key进行比较。<br>找到index后，在entry中线性搜索，确认是否真是存在。</p><p>entry中包含五个部分:</p><ul><li>shared 固定为0，</li><li>noshared key的长度</li><li>value_length value的长度</li><li>key key数据</li><li>value value数据</li></ul><p>shared字段存在的原因应该是跟leveldb结构保持一致，leveldb中块中的key分为前缀和后缀。<br>shared字段恒为0，表示并没有使用这个前缀后缀机制。</p><p>data段的数据结构跟index段数据结构基本一致。<br>差别是index段中的value存两个vint64字段，分别表示key所在的data段的偏移和长度。<br>也就是查询时，先在index段中找到data段的偏移和长度，然后在众多data段中再次查找，找到对应的value。</p><p>data段中的value是pb二进制文件，前面已经介绍过。</p><p>index文件的结构如下:</p><p><img src="/images/saved_model_file.png" alt></p><p>data文件结构相对简单，data文件的数量记录在header中，即key为空字符串的value里。</p><p>index文件里查询出的BundleEntryProto结构，可以定位到(shared_id, offset, size)三元组，直接读取即可。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> saved model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tfserving模型策略整理</title>
      <link href="/posts/ad28feb4.html"/>
      <url>/posts/ad28feb4.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文总结一下tensorflow serving的模型加载策略，以及模型serving策略。</p><h1 id="模型加载策略"><a href="#模型加载策略" class="headerlink" title="模型加载策略"></a>模型加载策略</h1><p>tf-serving支持多平台、多模型、多版本，支持制定模型维度的加载策略。<br>这个策略配置在serving-1.15.0/tensorflow_serving/config/model_server_config.proto中，字段如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version policy for the model indicating which version(s) of the model to</span></span><br><span class="line"><span class="comment">// load and make available for serving simultaneously.</span></span><br><span class="line"><span class="comment">// The default option is to serve only the latest version of the model.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (This can be changed once a model is in serving.)</span></span><br><span class="line">FileSystemStoragePathSourceConfig.ServableVersionPolicy model_version_policy = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>这个字段的定义在serving-1.15.0/tensorflow_serving/sources/storage_path/file_system_storage_path_source.proto中，内容如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A policy that dictates which version(s) of a servable should be served.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ServableVersionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Serve the latest versions (i.e. the ones with the highest version</span></span><br><span class="line">    <span class="comment">// numbers), among those found on disk.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is the default policy, with the default number of versions as 1.</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Latest</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Number of latest versions to serve. (The default is 1.)</span></span><br><span class="line">        <span class="built_in">uint32</span> num_versions = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serve all versions found on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">All</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serve a specific version (or set of versions).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This policy is useful for rolling back to a specific version, or for</span></span><br><span class="line">    <span class="comment">// canarying a specific version while still serving a separate stable</span></span><br><span class="line">    <span class="comment">// version.</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Specific</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The version numbers to serve.</span></span><br><span class="line">        <span class="keyword">repeated</span> <span class="built_in">int64</span> versions = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">oneof</span> policy_choice &#123;</span><br><span class="line">        Latest latest = <span class="number">100</span>;</span><br><span class="line">        All all = <span class="number">101</span>;</span><br><span class="line">        Specific specific = <span class="number">102</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>末尾policy_choice中可以判断使用的是哪种:</p><ul><li>latest 表示只加载最新版本</li><li>all 加载所有版本</li><li>specific 指定版本(可以多个版本)</li></ul><p>除此之外，AspiredVersionsManager类有两种版本管理策略:</p><ul><li>AvailabilityPreservingPolicy 先加载新版本，后卸载老版本</li><li>ResourcePreservingPolicy 先卸载老版本，后加载新版本</li></ul><h1 id="模型serving策略"><a href="#模型serving策略" class="headerlink" title="模型serving策略"></a>模型serving策略</h1><p>模型serving策略实际上是在加载策略基础上实现的。<br>在模型对应的配置中有字段version_labels，定义如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String labels to associate with versions of the model, allowing inference</span></span><br><span class="line"><span class="comment">// queries to refer to versions by label instead of number. Multiple labels</span></span><br><span class="line"><span class="comment">// can map to the same version, but not vice-versa.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An envisioned use-case for these labels is canarying tentative versions.</span></span><br><span class="line"><span class="comment">// For example, one can assign labels "stable" and "canary" to two specific</span></span><br><span class="line"><span class="comment">// versions. Perhaps initially "stable" is assigned to version 0 and "canary"</span></span><br><span class="line"><span class="comment">// to version 1. Once version 1 passes canary, one can shift the "stable"</span></span><br><span class="line"><span class="comment">// label to refer to version 1 (at that point both labels map to the same</span></span><br><span class="line"><span class="comment">// version -- version 1 -- which is fine). Later once version 2 is ready to</span></span><br><span class="line"><span class="comment">// canary one can move the "canary" label to version 2. And so on.</span></span><br><span class="line">map&lt;<span class="built_in">string</span>, <span class="built_in">int64</span>&gt; version_labels = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>这个字段可以指定版本的标签。</p><p>接着在请求包有的model_spec字段中，可以指定版本或者指定标签，如下:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Metadata for an inference request such as the model name and version.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ModelSpec</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Required servable name.</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional choice of which version of the model to use.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Recommended to be left unset in the common case. Should be specified only</span></span><br><span class="line">    <span class="comment">// when there is a strong version consistency requirement.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// When left unspecified, the system will serve the best available version.</span></span><br><span class="line">    <span class="comment">// This is typically the latest version, though during version transitions,</span></span><br><span class="line">    <span class="comment">// notably when serving on a fleet of instances, may be either the previous or</span></span><br><span class="line">    <span class="comment">// new version.</span></span><br><span class="line">    <span class="keyword">oneof</span> version_choice &#123;</span><br><span class="line">        <span class="comment">// Use this specific version number.</span></span><br><span class="line">        google.protobuf.Int64Value version = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the version associated with the given label.</span></span><br><span class="line">        <span class="built_in">string</span> version_label = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A named signature to evaluate. If unspecified, the default signature will</span></span><br><span class="line">    <span class="comment">// be used.</span></span><br><span class="line">    <span class="built_in">string</span> signature_name = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serving服务处理请求时，根据version_choice的取值来选择版本，默认是选择最新版本，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (model_spec.version_choice_case()) &#123;</span><br><span class="line">    <span class="keyword">case</span> ModelSpec::kVersion: &#123;</span><br><span class="line">        *servable_request = ServableRequest::Specific(model_spec.name(), model_spec.version().value());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ModelSpec::kVersionLabel: &#123;</span><br><span class="line">        <span class="keyword">if</span> (!options_.allow_version_labels) &#123;</span><br><span class="line">            <span class="keyword">return</span> errors::InvalidArgument(<span class="string">"ModelSpec has 'version_label' set, but it is not currently allowed by the server."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int64 version;</span><br><span class="line">        TF_RETURN_IF_ERROR(GetModelVersionForLabel(model_spec.name(), model_spec.version_label(), &amp;version));</span><br><span class="line">        *servable_request = ServableRequest::Specific(model_spec.name(), version);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ModelSpec::VERSION_CHOICE_NOT_SET: &#123;</span><br><span class="line">        *servable_request = ServableRequest::Latest(model_spec.name());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的模型选择需要与模型加载机制相配置，如果只加载了一个版本的模型，这时如果指定版本或者标签，就有可能找不到对应的模型，<br>这时就会返回标签不存在或者模型版本找不到的错误，然后请求失败，并没有兜底请求一说。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> serving </tag>
            
            <tag> model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow-serving--模型管理</title>
      <link href="/posts/ef7468b9.html"/>
      <url>/posts/ef7468b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>准备写几个文章来记录对tensorflow代码的阅读。<br>本文自顶向下介绍tensorflow-serving的架构，着重介绍一下模型管理及加载机制。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>tensorflow-serving（下文简称tfserving）是对tensorflow的封装，对外提供服务接口，关系类似lucene与es。<br>tfserving整体可以分为三层，接口层、模型管理层、tf引擎层，如下图所示:</p><p><img src="/images/tfserving-tf-serving_arch.jpg" alt></p><p>tfserving使用grpc作为服务框架，提供在线推理和模型状态查询的接口。与此同时，基于libevent实现了一个http服务，除了在线推理和模型状态查询接口外，还提供了prometheus接口用于监控。</p><p>模型管理层是serving的核心部分，负责维护模型的生命周期，重要的组件包括AspiredVersionsManager、BasicMananger、Adapter、Router、StoragePathSource等，下文将着重介绍。</p><p>tf引擎层实际是对tensorflow的封装，tfserving将其封装为Servable，通过模型名及其版本确认对应的模型，即三元组(name, version, model)。</p><h1 id="资源交互"><a href="#资源交互" class="headerlink" title="资源交互"></a>资源交互</h1><p>这部分讲一下从请求到来到推理进行里过程。<br>以推理为例子，调用层次如下:</p><ol><li>PredictionServiceImpl::Predict调用TensorflowPredictor::Predict进行预估</li><li>TensorflowPredictor::Predict调用TensorflowPredictor::PredictWithModelSpec进行预估<ol><li>调用ServerCore::GetServableHandle获取SavedModelBundle<ol><li>调用ServerCore::ServableRequestFromModelSpec构建查询包</li><li>调用AspiredVersionsManager::GetServableHandle获得servable<ul><li>AspiredVersionsManager::GetUntypedServableHandle 调用</li><li>BasicManager::GetUntypedServableHandle 调用<ul><li>ServingMap::GetUntypedServableHandle</li></ul><ol><li>根据ServableRequest查询HandlesMap获取对应的LoaderHarness</li><li>LoaderHarness取出Loader指针，使用SharedPtrHandle包裹后返回。</li></ol></li></ul></li></ol></li><li>调用internal::RunPredict进行预估<ol><li>输入映射(PreProcessPrediction)</li><li>执行Session::Run进行预估(已经在tensorflow代码里)</li><li>输出打包(PostProcessPredictionResult)</li></ol></li></ol></li></ol><p>TensorflowPredictor类是对推理流程的封装，保障grpc和http接口都能进行推理。<br>ServerCore类承接服务和模型。</p><p>ServerCore下的组件:</p><ul><li>AspiredVersionsManager 负责装载策略，控制装载卸载的模型版本<ul><li>BasicMananger 资源管理，提供资源管理、资源托管、资源装载卸载功能</li></ul></li><li>ServableStateMonitor 状态监视器，处理状态变化，并触发回调。</li><li>EventBus 消息总线，连接ServableStateMonitor和AspiredVersionsManager。</li><li>StoragePathSourceAndRouter</li><li>ResourceTracker</li></ul><h1 id="模型管理"><a href="#模型管理" class="headerlink" title="模型管理"></a>模型管理</h1><p>tfserving模型管理功能包括三个部分，模型配置热加载、模型版本侦测、模型加载卸载。</p><p>tfserving支持单模型和多模型两种模式，单模型通过入参控制加载的模型；多模型通过配置文件控制模型名、模型路径等。<br>模型配置热加载机制是针对多模型模式。</p><p>tfserving在这部分抽象了很多层，其目标是支持多种文件系统、支持多个平台(tf或者其他)、支持多个模型、支持模型的多个版本。考虑到这点就不难理解这个多层设计了。</p><h2 id="模型配置热加载"><a href="#模型配置热加载" class="headerlink" title="模型配置热加载"></a>模型配置热加载</h2><p>模型配置热加载机制是创建一个定时线程，按照入参配置的时间间隔，读取指定的配置文件，然后调用ServerCore::ReloadConfig函数，重新加载模型配置。这个地方可能出现内存泄漏问题。</p><p>创建定时线程的代码在<code>tensorflow_serving/model_servers/server.cc:343</code>;<br>配置读取逻辑在<code>tensorflow_serving/model_servers/server.cc:174</code>;<br>配置应用的逻辑在<code>tensorflow_serving/model_servers/server_core.cc:431</code>。</p><p>配置应用逻辑里，会先校验配置内容，然后更新模型对应的配置信息(模型的路径)。</p><h2 id="模型版本侦测"><a href="#模型版本侦测" class="headerlink" title="模型版本侦测"></a>模型版本侦测</h2><p>版本侦测就涉及到一套回调机制了，<code>Source<t>::AspiredVersionsCallback</t></code>，在代码serving-1.15.0/tensorflow_serving/core/source.h:87。<br>上层对象将回调函数注册给下层对象，下层对象侦测到状态后，调用这个回调函数，然后将信息传递给上层对象。</p><p>这里涉及到StoragePathSource、Router、Adapter、Manager等多个实例，他们之间的调用如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S<span class="function"><span class="title">toragePathSource</span> --&gt;</span> R<span class="function"><span class="title">outer</span> --&gt;</span> A<span class="function"><span class="title">dapter</span> --&gt;</span> AspiredVersionManager</span><br></pre></td></tr></table></figure><p>这里就牵扯到Source和Target关系了，即源和目标。Target提供回调函数给Source，Source按需调用该函数，回调绑定通过ConnectSourceToTarget连接。Router和Adapter既是Source又是Target。<br>ConnectSourcesWithFastInitialLoad中绑定了AspiredVersionManager和Adapter。<br>一个平台对应一个StoragePathSourceAdapter，存在SourceAdapters中。</p><p>StoragePathSource是TFS定义的对未加载模型对象的抽象, 目前实现了两种Source, 一种是StaticStoragePathSource,一种是FileSystemStoragePathSource. 前者是简单的静态的模型文件存储系统, 仅仅在启动时触发模型的加载, 没有其他动作. 后者是动态的Source, 能监测存储系统的变化并发出通知.</p><p>tfserving实现Source时将模块职责划分的很清晰, Source的职责就是监测变化, 如何处理则由Source的用户决定, 所以Source有一个接口SetAspiredVersionsCallback, 可以设置回调函数用于通知AspiredVersion的变化. Source在变化的时候就会调用设置的回调函数.</p><p>作为Source的对等对象, 系统也定义了Target, 有接口GetAspiredVersionsCallback, 用于获取处理AspiredVersions的回调接口, 然后我们就可以将Target和Source连起来了.</p><p>上述连接关系里面, Router和Adapter既是Source又是Target, AspiredVersionManager是Target. 但是Router没有实现Source接口, 而是要求在创建Router对象时直接将Adapter作为参数, 这样实现主要目的是创建一对多的关系.</p><p>系统根据所支持平台的个数（tensorflow算是一种平台）创建Adapter, 一种平台对应一个Adapter, 负责创建模型加载器Loader. 对于tensorflow平台, 对应的adapter是SavedModelBundleSourceAdapter.</p><p>Router负责根据模型名称查找对应的平台(model_config里面有指定平台名称), 从而定位到对应的Adapter.</p><p>这些连接关系是在系统启动, 或者更新model-config的时候建立的.</p><p>默认配置下, FileSystemStoragePathSource为Source的实例, SavedModelBundleSourceAdapter为Adapter的实例, DynamicSourceRouter为Router的实例.</p><p>FileSystemStoragePathSource有自己单独的工作线程, 周期查询文件系统, 发现每个模型的版本, 根据指定的servable_version_policy(model_config), 创建ServableData(模型名, 版本号, 路径), 传给Router<br>Router根据路由找到对应的adapter, 传给Adataper<br>Adapter将ServableData(模型名, 版本号, 路径)转换成ServableData(模型名, 版本, Loader), 传给AspiredVersionManager<br>AspiredVersionManager将这些信息存到pending_aspired_versions_requests_, 等待另外一个工作线程(AspiredVersionsManager_ManageState_Thread)处理</p><p>如下图左侧所示:</p><p><img src="/images/tf_model.jpg" alt></p><p>由于tfserving实际就 tensorflow这个平台，所以，上图实际情况如下图所示:</p><p><img src="/images/tf_model_1.jpg" alt></p><h2 id="模型加载卸载"><a href="#模型加载卸载" class="headerlink" title="模型加载卸载"></a>模型加载卸载</h2><p>模型的装在卸载就需要详细介绍一下AspiredVersionsManager、BasicMananger、servable类了。<br>AspiredVersionsManager是总控，一端连着版本发现，一端控制模型加载，内部有个更新线程进行将待更新队列中的数据取出，进行版本更新。<br>BasicMananger存粹是维护模型的版本数据；servable是存粹的模型版本。</p><h3 id="AspiredVersionsManager类"><a href="#AspiredVersionsManager类" class="headerlink" title="AspiredVersionsManager类"></a>AspiredVersionsManager类</h3><p>AspiredVersionsManager负责装载策略，控制装载卸载的模型版本。<br>成员对象包括:</p><ul><li>aspired_version_policy_ 装载策略</li><li>pending_aspired_versions_requests_ 待处理资源</li><li>manage_state_thread_ 定时任务，负责处理状态</li><li>target_impl_ 应该是IMPL模式对象</li><li>basic_manager_ BasicMananger类对象，资源管理</li><li>set_num_load_threads_observer_</li></ul><p>这个类对外(ServerCore)只提供了查询Servable的接口，用于获取模型。<br>这个类的对象创建之后，会启动一个后台线程去周期执行任务:</p><ul><li>FlushServables 清理（取消托管）无用或者状态有问题的资源</li><li>HandlePendingAspiredVersionsRequests<ul><li>当前资源正在卸载中的，跳过本次处理<ul><li>之前出现镜像版本不在新增版本中 (应该是该版本本地数据被删除，但是还没被卸载)</li><li>这次该版本出现在新增版本中</li></ul></li><li>处理选中版本逻辑<ul><li>获取新版本列表</li><li>获取当前版本列表</li><li>镜像版本不在新版本中，进行标记(本地数据已经被删除)</li><li>获取差集(新版本 - 当前版本)进行托管</li></ul></li></ul></li><li>InvokePolicyAndExecuteAction 筛选一个操作(模型装载或卸载)，并执行<ul><li>获取每个模型的每个版本的镜像状态</li><li>针对每个模型，使用装载策略器筛选一个“操作”（至多一个）</li><li>针对所有模型的“操作”，筛选(优先卸载)一个执行<br>调用basic_manager的装载或者卸载接口进行操作。</li></ul></li></ul><p>pending_aspired_versions_requests_存储等待处理队列，调用关系有点绕:</p><ul><li></li><li>AspiredVersionsManagerTargetImpl::SetAspiredVersions</li><li>AspiredVersionsManager::EnqueueAspiredVersionsRequest</li><li>添加pending_aspired_versions_requests_</li></ul><p>装载策略:</p><ul><li>AvailabilityPreservingPolicy</li><li>ResourcePreservingPolicy</li></ul><h3 id="BasicMananger类"><a href="#BasicMananger类" class="headerlink" title="BasicMananger类"></a>BasicMananger类</h3><p>BasicManager，负责资源管理，提供资源获取、资源托管、资源装载、资源卸载，主要结构如下:</p><ul><li>servable_event_bus_ 状态消息分发</li><li>managed_map_ 已托管的资源表，multimap&lt;模型名, LoaderHarness_Ptr&gt;</li><li>serving_map_ 就绪的模型表类，类型是ServingMap，里面也是multimap结构</li><li>load_executor_和unload_executor_是装载、卸载的线程池</li></ul><p>BasicManager提供的接口:</p><ul><li>ManageServable 托管资源<ol><li>从ServableData对象中取出Loader和ServableId，装入LoaderHarness</li><li>发布消息&lt;ServableId, kStart&gt;</li><li>加入managed_map_中进行管理</li></ol></li><li>LoadServable 装载资源，资源必须被托管<ol><li>构建LoadOrUnloadRequest对象</li><li>获取LoaderHarness对象</li><li>检查LoaderHarness对象是否已经装载</li><li>调度进行装载，配置了线程池就用线程池<ol><li>获取LoaderHarness对象</li><li>预先分配资源</li><li>修改资源状态为kLoadApproved</li><li>发布事件kLoading</li><li>调度LoaderHarness的Load函数进行装载</li><li>更新ServingMap数据</li><li>发布事件kAvailable</li></ol></li></ol></li><li>UnloadServable 卸载资源<ol><li>构建LoadOrUnloadRequest对象</li><li>获取LoaderHarness对象</li><li>检查LoaderHarness对象是否已经卸载</li><li>调度进行卸载，配置了线程池就用线程池<ol><li>获取LoaderHarness对象</li><li>修改资源状态为kQuiescing</li><li>发布事件kUnloading</li><li>更新ServingMap数据</li><li>修改新状态为kQuiesced</li><li>调度LoaderHarness的Unload函数进行卸载</li><li>发布事件kEnd</li></ol></li></ol></li><li>StopManagingServable 取消托管资源<ol><li>从managed_map_中删除资源</li></ol></li><li>GetUntypedServableHandle 获取资源<ol><li>从serving_map_中获取资源<ol><li>查询unordered_multimap里查询LoaderHarness对象</li><li>LoaderHarness中取出ServableId和Loader，装入SharedPtrHandle</li></ol></li></ol></li><li>其他查询接就不介绍了</li></ul><h3 id="servable类"><a href="#servable类" class="headerlink" title="servable类"></a>servable类</h3><p>一个servable对应一个模型的一个版本，这里涉及到多个类:</p><ul><li>SavedModelBundle 实际模型<ul><li>Session 对象</li><li>meta_graph_def graph申明</li></ul></li><li>ServableHandle 类似智能指针，但是不管理内存</li><li>UntypedServableHandle 基类，定义了获取servable的句柄。</li><li>SharedPtrHandle UntypedServableHandle的实现，从Loader中获取servable对象。</li><li>ServableRequest 用来查询manager获得指定版本模型的阐述对象(Params)</li></ul><p>他们的关系是: manager中存了SharedPtrHandle对象，通过ServableRequest查询对应的SharedPtrHandle；使用时将获取的使用ServableHandle将获取的SharedPtrHandle对象中的Loader维护的SavedModelBundle取出。</p><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>AspiredVersionsManager对象从队列中取到版本，跟自身的版本进行比较，得到需要更新的版本数据。<br>AspiredVersionsManager调用BasicMananger::LoadServable，装载模型。<br>BasicMananger进行一连串调用之后，LoaderHarness、SimpleLoader等之后，就到tensorflow里的代码了。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> tensorflow </tag>
            
            <tag> serving </tag>
            
            <tag> 模型 </tag>
            
            <tag> 推理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow源码阅读--前置准备</title>
      <link href="/posts/f4cfcd39.html"/>
      <url>/posts/f4cfcd39.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>准备写几个文章来记录对tensorflow代码的阅读。本文主要写tensorflow代码阅读准备。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>代码阅读前，还是需要准备一下装备来提升代码阅读效率，好的工具能提升代码阅读的效率，这里推荐使用CLion来阅读代码。<br>即使windows下，也可以用CLion阅读代码，虽然很多代码编译不过，但并不影响代码的阅读。</p><p>首先，我们需要选择一个阅读的版本，本文选择1.15版本。在github上建立代码库tf_read，然后在该目录下下载tensorflow/tensorflow和tensorflow/serving的代码（直接下载对应的tar包解压就行）。目前tf_read目录下的情况如下:</p><ul><li>serving-1.15.0 tf-serving的源码</li><li>tensorflow-1.15.0 tf的源码</li></ul><p>为了提升使用CLion阅读代码的时候效率，需要提前做一些工作，包括：生成pb产物、移除单测文件、屏蔽“无关”文件、添加构建目标。</p><h2 id="生成pb产物"><a href="#生成pb产物" class="headerlink" title="生成pb产物"></a>生成pb产物</h2><p>CLion代码分析时，会查找对应的头文件，如果proto编译产物不存在，则会影响代码的解析，也会影响代码跳转的准确率。<br>这时，我们需要手工编译一下proto文件，但是需要将编译产物放在特定的目录下，并将这个目录从全文搜索的路径里移除，避免搜索proto成员时出现一堆编译产物的搜索结果。<br>在根目录下创建pb_out目录用于存放proto编译产出。在serving-1.15.0目录下建立一个指向tensorflow-1.15.0/tensorflow的软链，因为serving下的部分proto依赖了tensorflow的proto。分别在serving-1.15.0和tensorflow-1.15.0目录下执行下面代码，进行手工编译:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc <span class="attribute">--cpp_out</span>=../pb_out `<span class="builtin-name">find</span> . -name <span class="string">'*.proto'</span>`</span><br></pre></td></tr></table></figure><p>然后在serving-1.15.0目录下单独执行grpc的编译命令:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc <span class="attribute">--grpc_out</span>=. <span class="attribute">--plugin</span>=protoc-gen-grpc=`which grpc_cpp_plugin` `<span class="builtin-name">find</span> tensorflow_serving/apis/ -name <span class="string">'*.proto'</span>`</span><br></pre></td></tr></table></figure><p>上面命令执行完毕后，选中pb_out目录，右键-将目录标记为-排除。接着在CMakeLists.txt中添加<code>include_directories(pb_out)</code>。</p><h2 id="移除单侧代码"><a href="#移除单侧代码" class="headerlink" title="移除单侧代码"></a>移除单侧代码</h2><p>由于tensorflow和serving是使用bazel构建的，单侧文件和源码文件都是放在一个目录里，影响CLion的全文搜索和“查找用法”等功能。这时建议把”<em>_test.cc”和”</em>_benchmark.cc”文件移动到特定目录下。<br>在根目录下建立test_dir目录，然后编写脚本将这两类文件移动到这个目录下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> `<span class="builtin-name">find</span> . -name <span class="string">'*_test.cc'</span> -o -name <span class="string">'*_benchmark.cc'</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    echo <span class="variable">$&#123;filename&#125;</span>;</span><br><span class="line">    <span class="attribute">origin_dir</span>=`dirname <span class="variable">$&#123;filename&#125;</span>`;</span><br><span class="line">    <span class="attribute">target_dir</span>=<span class="string">"test_dir/<span class="variable">$&#123;origin_dir&#125;</span>"</span>;</span><br><span class="line">    echo <span class="variable">$&#123;target_dir&#125;</span>;</span><br><span class="line">    mkdir -p <span class="variable">$&#123;target_dir&#125;</span>;</span><br><span class="line">    cp <span class="variable">$&#123;filename&#125;</span> <span class="variable">$&#123;target_dir&#125;</span>;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>执行上面的脚本后，单侧和压测代码就被移动到test_dir目录下，然后右键-将目录标记为-排除，这样就排除单侧对代码跳转的影响了。</p><h2 id="屏蔽“无关”文件"><a href="#屏蔽“无关”文件" class="headerlink" title="屏蔽“无关”文件"></a>屏蔽“无关”文件</h2><p>为了减少全文搜索时无关代码对结果的影响，建议将py、java、go、lite等相关代码目录直接排除（右键-将目录标记为-排除）。</p><h2 id="添加构建目标"><a href="#添加构建目标" class="headerlink" title="添加构建目标"></a>添加构建目标</h2><p>tensorflow是使用bazel构建的，虽然CLion有bazel插件，但是bazel经常崩溃，体验不是特别好，所以还是使用cmake来构建这个代码。<br>在CMakeLists.txt里添加下面代码，来添加构建目标（不是真的构建，只是用来阅读一下代码）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">17</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/apis SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/batching SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/config SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/core SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/model_servers SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/resources SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/servables/hashmap SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/servables/tensorflow SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/sources/storage_path SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/util SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/util/net_http/client SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/util/net_http/compression SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/util/net_http/internal SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/util/net_http/server/internal SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/util/net_http/server/public SERVER_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(serving-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow_serving/mytools SERVER_SRC)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(tf-server $&#123;SERVER_SRC&#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/client TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/framework TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/gradients TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/ops TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/profiler TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/saved_model TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/tools TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/cc/training TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/api_def TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/common_runtime TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/common_runtime/data TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/common_runtime/eager TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/common_runtime/gpu TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/common_runtime/sycl TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/debug TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/distributed_runtime TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/distributed_runtime/eager TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/distributed_runtime/rpc TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/framework TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/graph TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler/clusters TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler/costs TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler/graph_analyzer TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler/inputs TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler/optimizers TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler/utils TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/grappler/verifiers TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/batching_util TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/boosted_trees TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/boosted_trees/quantiles TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/data TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/fuzzing TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/hexagon TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/neon TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/rnn TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/kernels/tensor_forest TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/lib TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/lib/core TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/nccl TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/ops TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/ops/compat TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/platform TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/platform/cloud TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/platform/default TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/platform/hadoop TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/platform/posix TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/platform/profile_utils TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/platform/s3 TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/profiler TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/profiler/internal TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/profiler/lib TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/profiler/rpc TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/protobuf TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/summary TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/tpu TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/user_ops TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/util TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/util/ctc TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/util/proto TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/util/rpc TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/util/sparse TF_SRC)</span></span></span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(tensorflow-<span class="number">1.15</span>.<span class="number">0</span>/tensorflow/core/util/tensor_bundle TF_SRC)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(tf $&#123;TF_SRC&#125;)</span></span></span><br></pre></td></tr></table></figure><p>部分第三方库不在源码中，这时需要手工安装一下。mac用户可以直接用brew进行安装，同时在CMakeLists.txt里添加<code>include_directories(/usr/local/include)</code>; windows用户直接使用conan安装一下即可，conanfile.txt内容如下:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[build_requires]</span><br><span class="line"></span><br><span class="line">[requires]</span><br><span class="line">protobuf/<span class="number">3.9</span><span class="number">.1</span></span><br><span class="line">gflags/<span class="number">2.2</span><span class="number">.2</span></span><br><span class="line">glog/<span class="number">0.5</span><span class="number">.0</span></span><br><span class="line">abseil/<span class="number">20211102.0</span></span><br><span class="line">eigen/<span class="number">3.4</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">[generators]</span><br><span class="line">cmake_find_package</span><br><span class="line">cmake_paths</span><br><span class="line"></span><br><span class="line">[options]</span><br></pre></td></tr></table></figure><p>然后在CMakeLists.txt中添加下面内容:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">($&#123;CMAKE_BINARY_DIR&#125;/conan_paths.cmake)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(absl REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Protobuf REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Eigen3 REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">($&#123;absl_INCLUDE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">($&#123;protobuf_INCLUDE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">get_filename_component</span><span class="params">(Eigen3_INCLUDE_DIR_P $&#123;Eigen3_INCLUDE_DIR&#125; DIRECTORY)</span></span></span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">($&#123;Eigen3_INCLUDE_DIR_P&#125;)</span></span></span><br></pre></td></tr></table></figure><p>使用CLion看tensorflow的准备工作就做完了。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++语法面试题总结</title>
      <link href="/posts/ad9c07df.html"/>
      <url>/posts/ad9c07df.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>回顾一下c++语法的八股文，来自<a href="https://blog.csdn.net/luanfenlian0992/article/details/118771472" target="_blank" rel="noopener">某博客</a>和leetcode。</p><h1 id="编译内存相关"><a href="#编译内存相关" class="headerlink" title="编译内存相关"></a>编译内存相关</h1><h2 id="C-程序编译过程"><a href="#C-程序编译过程" class="headerlink" title="C++ 程序编译过程"></a>C++ 程序编译过程</h2><p>编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。</p><ul><li>编译预处理：处理以 # 开头的指令；</li><li>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；</li><li>汇编：将汇编代码 .s 翻译成机器指令 .o 文件；</li><li>链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe文件。</li></ul><p><img src="/images/cpp_review_1.png" alt></p><p>链接分为两种：</p><ul><li>静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ul><p>二者的优缺点：</p><ul><li>静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</li></ul><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h2><p>C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。</p><ul><li>栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</li><li>堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在.bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li><li>常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。</li><li>代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li></ul><h2 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h2><ul><li>申请方式：栈是系统自动分配，堆是程序员主动申请。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li><li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li><li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li><li>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</li></ul><h2 id="变量的区别"><a href="#变量的区别" class="headerlink" title="变量的区别"></a>变量的区别</h2><p>全局变量、局部变量、静态全局变量、静态局部变量的区别：</p><p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p><p>从作用域看：</p><ul><li>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。</li><li>静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li><li>局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li><li>静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</li></ul><p>从分配内存空间看：</p><ul><li>静态存储区：全局变量，静态局部变量，静态全局变量。</li><li>栈：局部变量。</li></ul><h2 id="全局变量定义在头文件中有什么问题？"><a href="#全局变量定义在头文件中有什么问题？" class="headerlink" title="全局变量定义在头文件中有什么问题？"></a>全局变量定义在头文件中有什么问题？</h2><p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</p><p>内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中<br>内存对齐的原则：</p><ol><li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量 （offset）都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</li></ol><p>进行内存对齐的原因：（主要是硬件设备方面的问题）</p><ol><li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li><li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li><li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li><li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignmenttrap）；</li><li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li></ol><p>内存对齐的优点：</p><ol><li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li><li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li></ol><h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。<br>进一步解释：</p><ul><li>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</li><li>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</li><li>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete释放内存，否则这块内存就会造成内存泄漏。</li><li>指针重新赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">char</span> *p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p = np;</span><br></pre></td></tr></table></figure><p>开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p><h2 id="怎么防止内存泄漏？内存泄漏检测工具的原理？"><a href="#怎么防止内存泄漏？内存泄漏检测工具的原理？" class="headerlink" title="怎么防止内存泄漏？内存泄漏检测工具的原理？"></a>怎么防止内存泄漏？内存泄漏检测工具的原理？</h2><p>防止内存泄漏的方法：</p><ol><li>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）</li><li>智能指针：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</li></ol><p>内存泄漏检测工具的实现原理：内存检测工具有很多，这里重点介绍下 valgrind 。</p><h2 id="智能指针有哪几种？智能指针的实现原理？"><a href="#智能指针有哪几种？智能指针的实现原理？" class="headerlink" title="智能指针有哪几种？智能指针的实现原理？"></a>智能指针有哪几种？智能指针的实现原理？</h2><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 &lt; memory &gt; 头文件中。</p><p>C++11 中智能指针包括以下三种：</p><ul><li>共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li><li>独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。</li><li>弱指针（weak_ptr）：指向 shared_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。</li></ul><p>智能指针的实现原理： 计数原理。<br>示例代码如下（实际实现中计数器使用atomic）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> : </span><br><span class="line">T *_ptr;</span><br><span class="line">size_t *_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SmartPtr(T *ptr = nullptr) : _ptr(ptr) &#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr) &#123;</span><br><span class="line">_count = new size_t(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_count = new size_t(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~SmartPtr() &#123;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span><br><span class="line">delete <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">delete <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造：计数 +1</span></span><br><span class="line">SmartPtr(<span class="keyword">const</span> SmartPtr &amp;ptr) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载 </span></span><br><span class="line">SmartPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr &amp;ptr) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) &#123;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span><br><span class="line">delete <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">delete <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)++; <span class="comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">assert(<span class="keyword">this</span>-&gt;_ptr == nullptr);</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T *<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">assert(<span class="keyword">this</span>-&gt;_ptr == nullptr);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t use_count() &#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？"><a href="#一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？" class="headerlink" title="一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？"></a>一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？</h2><p>借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。<br>也可以让当前unique_ptr调用release释放对ptr控制权，然后在另一个unique_ptr获取控制权。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 作为一个类 </span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; ptr2 = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr1);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">ptr3</span><span class="params">(ptr2.<span class="built_in">release</span>())</span></span>;</span><br></pre></td></tr></table></figure><h2 id="使用智能指针会出现什么问题？怎么解决？"><a href="#使用智能指针会出现什么问题？怎么解决？" class="headerlink" title="使用智能指针会出现什么问题？怎么解决？"></a>使用智能指针会出现什么问题？怎么解决？</h2><p>智能指针可能出现的问题：循环引用</p><p>在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;setChild(c);</span><br><span class="line">        c-&gt;setPartent(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; wpp.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; wpc.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环引用的解决方法： weak_ptr</p><p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p><ul><li>weak_ptr 对被 shared_ptr 管理的对象存在非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr；</li><li>weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</li><li>weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line">    weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.lock()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;setChild(c);</span><br><span class="line">        c-&gt;setPartent(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; wpp.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; wpc.use_count() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shared-from-this使用"><a href="#shared-from-this使用" class="headerlink" title="shared_from_this使用"></a>shared_from_this使用</h2><p>当成员函数中需要将当前类对象的指针传递给其他对象A时，由于对象A的生命周期未知，直接传this指针可能造成非预期结果。<br>为了解决这个问题，c++从boost中吸收了enable_shared_from_this类，示例代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> :</span> <span class="keyword">public</span> enable_shared_from_this&lt;TestA&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">TestA()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"TestA create"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~TestA()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"TesA destory"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;TestA&gt; <span class="title">getSharedFromThis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> shared_from_this(); &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#123;<span class="comment">//出了此作用域 ptr1 ptr2 销毁， TestA对象销毁</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;TestA&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> TestA())</span></span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;TestA&gt; ptr2 = ptr1-&gt;getSharedFromThis();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr1 count: "</span> &lt;&lt; ptr1.use_count() &lt;&lt; <span class="string">" ptr2 count: "</span> &lt;&lt; ptr2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出：ptr1 count: 2 ptr2 count: 2  可以正常释放对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这种用法在boost的asio中使用比较广泛。</p><h1 id="c-11新特性"><a href="#c-11新特性" class="headerlink" title="c++11新特性"></a>c++11新特性</h1><h2 id="auto-类型推导"><a href="#auto-类型推导" class="headerlink" title="auto 类型推导"></a>auto 类型推导</h2><p>auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。<br>auto 关键字基本的使用语法如下：</p><h2 id="decltype-类型推导"><a href="#decltype-类型推导" class="headerlink" title="decltype 类型推导"></a>decltype 类型推导</h2><p>decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。</p><p>区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = val1 + val2; </span><br><span class="line"><span class="keyword">decltype</span>(val1 + val2) var1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>auto 根据 = 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。</li><li>auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。</li></ul><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数。</p><p>lambda匿名函数的定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; return type</span><br><span class="line">&#123;</span><br><span class="line">   function body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。</li><li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行升序排序</span></span><br><span class="line">    sort(arr, arr+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : arr)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范围-for-语句"><a href="#范围-for-语句" class="headerlink" title="范围 for 语句"></a>范围 for 语句</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">for</span> (<span class="attribute">declaration </span>: expression)&#123;</span><br><span class="line">    <span class="selector-tag">statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数的含义：</p><ul><li>expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。</li><li>declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。</li></ul><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用：绑定到右值的引用，用 &amp;&amp; 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;l_var = var;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;r_var = var; <span class="comment">// error: cannot bind rvalue reference of type 'int&amp;&amp;' to lvalue of type 'int' 错误：不能将右值引用绑定到左值上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;r_var2 = var + <span class="number">40</span>; <span class="comment">// 正确：将 r_var2 绑定到求和结果上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准库-move-函数"><a href="#标准库-move-函数" class="headerlink" title="标准库 move() 函数"></a>标准库 move() 函数</h2><p>move() 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。该知识点会在后续的章节中做详细的说明。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>上面已经详述</p><h2 id="delete-函数和-default-函数"><a href="#delete-函数和-default-函数" class="headerlink" title="delete 函数和 default 函数"></a>delete 函数和 default 函数</h2><ul><li>delete 函数：= delete 表示该函数不能被调用。</li><li>default 函数：= default 表示编译器生成默认的函数，例如：生成默认的构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() = <span class="keyword">default</span>; <span class="comment">// 表示使用默认的构造函数</span></span><br><span class="line">~A() = <span class="keyword">default</span>;<span class="comment">// 表示使用默认的析构函数</span></span><br><span class="line">A(<span class="keyword">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">// 表示类的对象禁止拷贝构造</span></span><br><span class="line">A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">// 表示类的对象禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A ex1;</span><br><span class="line">A ex2 = ex1; <span class="comment">// error: use of deleted function 'A::A(const A&amp;)'</span></span><br><span class="line">A ex3;</span><br><span class="line">ex3 = ex1; <span class="comment">// error: use of deleted function 'A&amp; A::operator=(const A&amp;)'</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是面向对象？面向对象的三大特性"><a href="#什么是面向对象？面向对象的三大特性" class="headerlink" title="什么是面向对象？面向对象的三大特性"></a>什么是面向对象？面向对象的三大特性</h2><p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p><p>面向对象的三大特性：</p><ul><li>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li><li>继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li><li>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</li></ul><h2 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h2><p>重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> tmp);</span><br><span class="line">    void <span class="function"><span class="keyword">fun</span>(<span class="title">float</span></span> tmp);        <span class="regexp">//</span> 重载 参数类型不同（相对于上一个函数）</span><br><span class="line">    void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> tmp, float tmp1); <span class="regexp">//</span> 重载 参数个数不同（相对于上一个函数）</span><br><span class="line">    void <span class="function"><span class="keyword">fun</span>(<span class="title">float</span></span> tmp, int tmp1); <span class="regexp">//</span> 重载 参数顺序不同（相对于上一个函数）</span><br><span class="line">    int <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> tmp);            <span class="regexp">//</span> <span class="symbol">error:</span> <span class="string">'int A::fun(int)'</span> cannot be overloaded 错误：注意重载不关心函数返回类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    void <span class="function"><span class="title">fun</span><span class="params">(int tmp, float tmp1)</span></span> &#123; cout &lt;&lt; <span class="string">"Base::fun(int tmp, float tmp1)"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> : <span class="type">public Base</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    void <span class="function"><span class="title">fun</span><span class="params">(int tmp)</span></span> &#123; cout &lt;&lt; <span class="string">"Derive::fun(int tmp)"</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex<span class="function">.<span class="title">fun</span><span class="params">(<span class="number">1</span>)</span></span>;       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex<span class="function">.<span class="title">fun</span><span class="params">(<span class="number">1</span>, <span class="number">0.01</span>)</span></span>; <span class="comment">// error: candidate expects 1 argument, 2 provided</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：上述代码中 ex.fun(1, 0.01); 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。</p><p>重写(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun(int tmp) : "</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::fun(int tmp) : "</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>; &#125; <span class="comment">// 重写基类中的 fun 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived();</span><br><span class="line">    p-&gt;fun(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写和重载的区别：</p><ul><li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li><li>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。</li><li>virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</li></ul><p>隐藏和重写，重载的区别：</p><ul><li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li><li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</li></ul><h2 id="如何理解-C-是面向对象编程"><a href="#如何理解-C-是面向对象编程" class="headerlink" title="如何理解 C++ 是面向对象编程"></a>如何理解 C++ 是面向对象编程</h2><p>说明：该问题最好结合自己的项目经历进行展开解释，或举一些恰当的例子，同时对比下面向过程编程。</p><ul><li>面向过程编程：一种以执行程序操作的过程或函数为中心编写软件的方法。程序的数据通常存储在变量中，与这些过程是分开的。所以必须将变量传递给需要使用它们的函数。缺点：随着程序变得越来越复杂，程序数据与运行代码的分离可能会导致问题。例如，程序的规范经常会发生变化，从而需要更改数据的格式或数据结构的设计。当数据结构发生变化时，对数据进行操作的代码也必须更改为接受新的格式。查找需要更改的所有代码会为程序员带来额外的工作，并增加了使代码出现错误的机会。</li><li>面向对象编程（Object-Oriented Programming, OOP）：以创建和使用对象为中心。一个对象（Object）就是一个软件实体，它将数据和程序在一个单元中组合起来。对象的数据项，也称为其属性，存储在成员变量中。对象执行的过程被称为其成员函数。将对象的数据和过程绑定在一起则被称为封装。</li></ul><p>面向对象编程进一步说明：</p><p>面向对象编程将数据成员和成员函数封装到一个类中，并声明数据成员和成员函数的访问级别（public、private、protected），以便控制类对象对数据成员和函数的访问，对数据成员起到一定的保护作用。而且在类的对象调用成员函数时，只需知道成员函数的名、参数列表以及返回值类型即可，无需了解其函数的实现原理。当类内部的数据成员或者成员函数发生改变时，不影响类外部的代码。</p><h2 id="什么是多态？多态如何实现？"><a href="#什么是多态？多态如何实现？" class="headerlink" title="什么是多态？多态如何实现？"></a>什么是多态？多态如何实现？</h2><p>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p><p>实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p><p>实现过程：</p><ul><li>在类中用 virtual 关键字声明的函数叫做虚函数；</li><li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li><li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::fun()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *p = <span class="keyword">new</span> Derive();</span><br><span class="line">p-&gt;fun(); <span class="comment">// Derive::fun() 调用派生类中的虚函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类的虚函数表如下：</p><p><img src="/images/cpp_review_2.png" alt></p><p>派生类的对象虚函数表如下：</p><p><img src="/images/cpp_review_3.png" alt></p><p>简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 Derive::f() 进行调用。</p><h1 id="关键字库函数"><a href="#关键字库函数" class="headerlink" title="关键字库函数"></a>关键字库函数</h1><h2 id="sizeof-和-strlen-的区别"><a href="#sizeof-和-strlen-的区别" class="headerlink" title="sizeof 和 strlen 的区别"></a>sizeof 和 strlen 的区别</h2><p>strlen 是头文件 中的函数，sizeof 是 C++ 中的运算符。<br>strlen 测量的是字符串的实际长度（其源代码如下），以 \0 结束。而 sizeof 测量的是字符数组的分配大小。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">strlen</span> 源代码:</span><br><span class="line">size_t <span class="keyword">strlen</span>(const char *<span class="keyword">str</span>) &#123;</span><br><span class="line">    size_t <span class="keyword">length</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">while</span> (*<span class="keyword">str</span>++)</span><br><span class="line">        ++<span class="keyword">length</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">length</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">size_of</span><span class="params">(<span class="keyword">char</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' .</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">20</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    size_of(arr); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在编译时，计算长度；<br>sizeof 的参数可以是类型，也可以是变量；strlen 的参数必须是 char* 类型的变量。</p><h2 id="lambda-表达式（匿名函数）的具体应用和使用场景"><a href="#lambda-表达式（匿名函数）的具体应用和使用场景" class="headerlink" title="lambda 表达式（匿名函数）的具体应用和使用场景"></a>lambda 表达式（匿名函数）的具体应用和使用场景</h2><p>lambda 表达式的定义形式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; reurn type</span><br><span class="line">&#123;</span><br><span class="line">   function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [=]。</li><li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li></ul><p>举例：<br>lambda 表达式常搭配排序算法使用。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">76</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">90</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;); <span class="comment">// 降序排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：90 76 54 34 12 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="explicit-的作用（如何避免编译器进行隐式类型转换）"><a href="#explicit-的作用（如何避免编译器进行隐式类型转换）" class="headerlink" title="explicit 的作用（如何避免编译器进行隐式类型转换）"></a>explicit 的作用（如何避免编译器进行隐式类型转换）</h2><p>作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。</p><p>隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    A(<span class="keyword">int</span> tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        var = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A ex = <span class="number">10</span>; <span class="comment">// 发生了隐式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，A ex = 10; 在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：</p><p>为了避免隐式转换，可用 explicit 关键字进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        var = tmp;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    A ex1 = <span class="number">10</span>; <span class="comment">// error: conversion from 'int' to non-scalar type 'A' requested</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-和-C-static-的区别"><a href="#C-和-C-static-的区别" class="headerlink" title="C 和 C++ static 的区别"></a>C 和 C++ static 的区别</h2><p>在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数<br>在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</p><h2 id="static-的作用"><a href="#static-的作用" class="headerlink" title="static 的作用"></a>static 的作用</h2><p>作用：<br>static 定义静态变量，静态函数。</p><p>保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    static int <span class="keyword">var</span> = <span class="number">1</span>; <span class="comment">// var 只在第一次进入这个函数的时初始化</span></span><br><span class="line">    <span class="keyword">var</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    cout &lt;&lt; <span class="function"><span class="title">fun</span><span class="params">()</span></span> &lt;&lt; <span class="string">" "</span>; <span class="comment">// 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐藏：static作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）</p><p>static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var; <span class="comment">// 静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s_var++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s_show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s_var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member 'A::a' in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var</span></span><br><span class="line">        <span class="comment">// show();  // error: cannot call member function 'void A::show()' without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::s_var = <span class="number">1</span>;  <span class="comment">// 静态成员变量在类外进行初始化赋值，默认初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cout &lt;&lt; A::sa &lt;&lt; endl;    // error: 'int A::sa' is private within this context</span></span><br><span class="line">    A ex;</span><br><span class="line">    ex.show();</span><br><span class="line">    A::s_show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static-在类中使用的注意事项（定义、初始化和使用）"><a href="#static-在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="static 在类中使用的注意事项（定义、初始化和使用）"></a>static 在类中使用的注意事项（定义、初始化和使用）</h2><p>static 静态成员变量：</p><ul><li>静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现static关键字和private、public、protected 访问规则。</li><li>静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。</li><li>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i = s_var)</span></span>; <span class="comment">// 正确，静态成员变量可以作为成员函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> i = var)</span></span>;   <span class="comment">//  error: invalid use of non-static data member 'A::var'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> A s_var; <span class="comment">// 正确，静态数据成员</span></span><br><span class="line">    A var;          <span class="comment">// error: field 'var' has incomplete type 'A'</span></span><br><span class="line">    A *p;           <span class="comment">// 正确，指针</span></span><br><span class="line">    A &amp;var1;        <span class="comment">// 正确，引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static 静态成员函数：</p><ul><li>静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数。</li><li>静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。</li></ul><h2 id="static-全局变量和普通全局变量的异同"><a href="#static-全局变量和普通全局变量的异同" class="headerlink" title="static 全局变量和普通全局变量的异同"></a>static 全局变量和普通全局变量的异同</h2><p>相同点：</p><ul><li>存储方式：普通全局变量和 static 全局变量都是静态存储方式。</li></ul><p>不同点：</p><ul><li>作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li><li>初始化：静态全局变量只初始化一次，防止在其他文件中使用。</li></ul><h2 id="const-作用及用法"><a href="#const-作用及用法" class="headerlink" title="const 作用及用法"></a>const 作用及用法</h2><p>作用：</p><ul><li>const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</li><li>const 修饰函数参数，使得传递过来的函数参数的值不能改变。</li><li>const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</li></ul><p>在类中的用法：</p><p>const 成员变量：</p><ul><li>const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li><li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。</li></ul><p>const 成员函数：</p><ul><li>不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。</li><li>不能调用非常量成员函数，以防修改成员变量的值。</li></ul><h2 id="define-和-const-的区别"><a href="#define-和-const-的区别" class="headerlink" title="define 和 const 的区别"></a>define 和 const 的区别</h2><p>区别：</p><ul><li>编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</li><li>安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</li><li>内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。</li><li>调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；cons定义的常量可以进行调试。</li></ul><p>const 的优点：</p><ul><li>有数据类型，在定义式可进行安全性检查。</li><li>可调式。</li><li>占用较少的空间。</li></ul><h2 id="define-和-typedef-的区别"><a href="#define-和-typedef-的区别" class="headerlink" title="define 和 typedef 的区别"></a>define 和 typedef 的区别</h2><ul><li>原理：#define 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 typedef 。</li><li>功能：typedef 用来定义类型的别名，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li><li>作用域：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef 有自己的作用域。</li><li>指针的操作：typedef 和 #define 在处理指针时不完全一样</li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#define INTPTR1 int *</span></span><br><span class="line">typedef<span class="built_in"> int </span>* INTPTR2;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INTPTR1 p1, p2; // p1:<span class="built_in"> int </span>*; p2: int</span><br><span class="line">    INTPTR2 p3, p4; // p3:<span class="built_in"> int </span>*; p4:<span class="built_in"> int </span>*</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> int </span>var = 1;</span><br><span class="line">   <span class="built_in"> const </span>INTPTR1 p5 = &amp;var; // 相当于<span class="built_in"> const </span>int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span><br><span class="line">   <span class="built_in"> const </span>INTPTR2 p6 = &amp;var; // 相当于<span class="built_in"> int </span>*<span class="built_in"> const </span>p6; 指针常量，不可使 p6 再指向其他内容。</span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return </span>0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用宏实现比较大小，以及两个数中的最小值"><a href="#用宏实现比较大小，以及两个数中的最小值" class="headerlink" title="用宏实现比较大小，以及两个数中的最小值"></a>用宏实现比较大小，以及两个数中的最小值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(X, Y) ((X)&gt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(X, Y) ((X)&lt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">10</span>, var2 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX(var1, var2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MIN(var1, var2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行结果：</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>4.12 inline 作用及使用方法<br>作用：<br>inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。</p><p>使用方法：</p><p>类内定义成员函数默认是内联函数<br>在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    A(<span class="keyword">int</span> tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类外定义成员函数，若想定义为内联函数，需用关键字声明<br>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    A(<span class="keyword">int</span> tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。只要确保在调用该函数之前把 inline 的信息告知编译器即可。</p><h2 id="inline-函数工作原理"><a href="#inline-函数工作原理" class="headerlink" title="inline 函数工作原理"></a>inline 函数工作原理</h2><ul><li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</li><li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</li></ul><h2 id="宏定义（define）和内联函数（inline）的区别"><a href="#宏定义（define）和内联函数（inline）的区别" class="headerlink" title="宏定义（define）和内联函数（inline）的区别"></a>宏定义（define）和内联函数（inline）的区别</h2><ul><li>内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li><li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</li><li>宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fun_max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX(var, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fun_max(var, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行结果：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="new-的作用？"><a href="#new-的作用？" class="headerlink" title="new 的作用？"></a>new 的作用？</h2><p>new 是 C++ 中的关键字，用来动态分配内存空间，实现方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h2 id="new-和-malloc-如何判断是否申请到内存？"><a href="#new-和-malloc-如何判断是否申请到内存？" class="headerlink" title="new 和 malloc 如何判断是否申请到内存？"></a>new 和 malloc 如何判断是否申请到内存？</h2><ul><li>malloc ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。</li><li>new ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bac_alloc 异常。</li></ul><h2 id="delete-实现原理？delete-和-delete-的区别？"><a href="#delete-实现原理？delete-和-delete-的区别？" class="headerlink" title="delete 实现原理？delete 和 delete[] 的区别？"></a>delete 实现原理？delete 和 delete[] 的区别？</h2><p>delete 的实现原理：</p><ul><li>首先执行该对象所属类的析构函数；</li><li>进而通过调用 operator delete 的标准库函数来释放所占的内存空间。</li></ul><p>delete 和 delete [] 的区别：</p><ul><li>delete 用来释放单个对象所占的空间，只会调用一次析构函数；</li><li>delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</li></ul><h2 id="new-和-malloc-的区别，delete-和-free-的区别"><a href="#new-和-malloc-的区别，delete-和-free-的区别" class="headerlink" title="new 和 malloc 的区别，delete 和 free 的区别"></a>new 和 malloc 的区别，delete 和 free 的区别</h2><p>在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。</p><ul><li>malloc、free 是库函数，而new、delete 是关键字。</li><li>new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。</li><li>new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。</li><li>new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。</li><li>对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。malloc、free 无法进行自定义类型的对象的构造和析构。</li><li>new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）</li></ul><h2 id="malloc-的原理？malloc-的底层实现？"><a href="#malloc-的原理？malloc-的底层实现？" class="headerlink" title="malloc 的原理？malloc 的底层实现？"></a>malloc 的原理？malloc 的底层实现？</h2><p>malloc 的原理:</p><ul><li>当开辟的空间小于 128K 时，调用 brk() 函数，通过移动 _enddata 来实现；</li><li>当开辟空间大于 128K 时，调用 mmap() 函数，通过在虚拟地址空间中开辟一块内存空间来实现。</li></ul><p>malloc 的底层实现：</p><ul><li>brk() 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 _enddata。</li><li>mmap 内存映射原理：<ol><li>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；</li><li>调用内核空间的系统调用函数 mmap()，实现文件物理地址和进程虚拟地址的一一映射关系；</li><li>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</li></ol></li></ul><h2 id="C-和-C-struct-的区别？"><a href="#C-和-C-struct-的区别？" class="headerlink" title="C 和 C++ struct 的区别？"></a>C 和 C++ struct 的区别？</h2><ul><li>在 C 语言中 struct 是用户自定义数据类型；在 C++ 中 struct 是抽象数据类型，支持成员函数的定义。</li><li>C 语言中 struct 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 struct 可以和类一样，有访问权限，并可以定义成员函数。</li><li>C 语言中 struct 定义的自定义数据类型，在定义该类型的变量时，需要加上 struct 关键字，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var;</li></ul><h2 id="为什么有了-class-还保留-struct？"><a href="#为什么有了-class-还保留-struct？" class="headerlink" title="为什么有了 class 还保留 struct？"></a>为什么有了 class 还保留 struct？</h2><p>C++ 是在 C 语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了 struct。</p><h2 id="struct-和-union-的区别"><a href="#struct-和-union-的区别" class="headerlink" title="struct 和 union 的区别"></a>struct 和 union 的区别</h2><p>说明：union 是联合体，struct 是结构体。</p><p>区别：</p><ul><li>联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。</li><li>对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</li><li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> cc1; <span class="comment">// char 1 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// int 4 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// double 8 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u33;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">&#125; s11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">char</span> cc;  <span class="comment">// 1（char）+ 1（char）= 2 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 2 + 6（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">&#125; s22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">    <span class="keyword">char</span> cc;  <span class="comment">// 16 + 1（char）+ 7（内存对齐）= 24 字节</span></span><br><span class="line">&#125; s33;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(u11) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(u22) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(u33) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s11) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s22) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(s33) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.23 class 和 struct 的异同</p><ul><li>struct 和 class 都可以自定义数据类型，也支持继承操作。</li><li>struct 中默认的访问级别是 public，默认的继承级别也是 public；class 中默认的访问级别是 private，默认的继承级别也是 private。</li><li>当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于 class 或 struct 本身，class（private 继承），struct（public 继承），即取决于派生类的默认继承级别。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>&#125;；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A&#123;&#125;; <span class="comment">// private 继承 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> B&#123;&#125;； <span class="comment">// public 继承</span></span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span> A&#123; <span class="comment">// 由于 B 是 struct，A 的默认继承级别为 public</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> B&#123; <span class="comment">// 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A ex1;</span><br><span class="line">    ex1.funA(); <span class="comment">// class A</span></span><br><span class="line"></span><br><span class="line">    B ex2;</span><br><span class="line">    ex2.funA(); <span class="comment">// class A</span></span><br><span class="line">    ex2.funB(); <span class="comment">// class B</span></span><br><span class="line"></span><br><span class="line">    C ex3;</span><br><span class="line">    ex3.funB(); <span class="comment">// error: 'B' is not an accessible base of 'C'.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class 可以用于定义模板参数，struct 不能用于定义模板参数。</p><h2 id="volatile-的作用？是否具有原子性，对编译器有什么影响？"><a href="#volatile-的作用？是否具有原子性，对编译器有什么影响？" class="headerlink" title="volatile 的作用？是否具有原子性，对编译器有什么影响？"></a>volatile 的作用？是否具有原子性，对编译器有什么影响？</h2><p>volatile 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 violatile，告知编译器不应对这样的对象进行优化。</p><p>volatile不具有原子性。</p><p>volatile 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</p><h2 id="什么情况下一定要用-volatile，-能否和-const-一起使用？"><a href="#什么情况下一定要用-volatile，-能否和-const-一起使用？" class="headerlink" title="什么情况下一定要用 volatile， 能否和 const 一起使用？"></a>什么情况下一定要用 volatile， 能否和 const 一起使用？</h2><p>使用 volatile 关键字的场景：</p><ul><li>当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰；</li><li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰。</li></ul><p>volatile 关键字和 const 关键字可以同时使用，某种类型可以既是 volatile 又是 const ，同时具有二者的属性。</p><h2 id="返回函数中静态变量的地址会发生什么？"><a href="#返回函数中静态变量的地址会发生什么？" class="headerlink" title="返回函数中静态变量的地址会发生什么？"></a>返回函数中静态变量的地址会发生什么？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line">    var *= tmp;</span><br><span class="line">    <span class="keyword">return</span> &amp;var;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *fun(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：上述代码中在函数 fun 中定义了静态局部变量 var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。</p><h2 id="extern-C-的作用？"><a href="#extern-C-的作用？" class="headerlink" title="extern C 的作用？"></a>extern C 的作用？</h2><p>当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即 extern “C” 指出任意非 C++ 函数所用的语言。<br>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.28 sizeof(1==1) 在 C 和 C++ 中分别是什么结果？<br>C 语言代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(<span class="number">1</span>==<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>C++ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="number">1</span>==<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="memcpy-函数的底层原理？"><a href="#memcpy-函数的底层原理？" class="headerlink" title="memcpy 函数的底层原理？"></a>memcpy 函数的底层原理？</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *psrc;</span><br><span class="line">    <span class="keyword">char</span> *pdst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src &lt; dst) &amp;&amp; (<span class="keyword">char</span> *)src + <span class="built_in">size</span> &gt; (<span class="keyword">char</span> *)dst) <span class="comment">// 出现地址重叠的情况，自后向前拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="keyword">char</span> *)src + <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">        pdst = (<span class="keyword">char</span> *)dst + <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">size</span>--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst-- = *psrc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="keyword">char</span> *)src;</span><br><span class="line">        pdst = (<span class="keyword">char</span> *)dst;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">size</span>--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="strcpy-函数有什么缺陷？"><a href="#strcpy-函数有什么缺陷？" class="headerlink" title="strcpy 函数有什么缺陷？"></a>strcpy 函数有什么缺陷？</h2><p>strcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">0x11112222</span>;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Address : var "</span> &lt;&lt; &amp;var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Address : arr "</span> &lt;&lt; &amp;arr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arr, <span class="string">"hello world!"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"var:"</span> &lt;&lt; hex &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 将变量 var 以 16 进制输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"arr:"</span> &lt;&lt; arr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Address : var 0x23fe4c</span></span><br><span class="line"><span class="comment">Address : arr 0x23fe42</span></span><br><span class="line"><span class="comment">var:11002164</span></span><br><span class="line"><span class="comment">arr:hello world!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：从上述代码中可以看出，变量 var 的后六位被字符串 “hello world!” 的 “d!\0” 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：\0(0x00)，!(0x21)，d(0x64)。<br>原因：变量 arr 只分配的 10 个内存空间，通过上述程序中的地址可以看出 arr 和 var 在内存中是连续存放的，但是在调用 strcpy 函数进行拷贝时，源字符串 “hello world!” 所占的内存空间为 13，因此在拷贝的过程中会占用 var 的内存空间，导致 var的后六位被覆盖。</p><h2 id="auto-类型推导的原理"><a href="#auto-类型推导的原理" class="headerlink" title="auto 类型推导的原理"></a>auto 类型推导的原理</h2><p>auto 类型推导的原理：<br>编译器根据初始值来推算变量的类型，要求用 auto 定义变量时必须有初始值。编译器推断出来的 auto 类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。</p><h1 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h1><h2 id="什么是虚函数？什么是纯虚函数？"><a href="#什么是虚函数？什么是纯虚函数？" class="headerlink" title="什么是虚函数？什么是纯虚函数？"></a>什么是虚函数？什么是纯虚函数？</h2><p>虚函数：被 virtual 关键字修饰的成员函数，就是虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_fun</span><span class="params">()</span> <span class="comment">// 虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::v_fun()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">v_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::v_fun()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> B();</span><br><span class="line">    p-&gt;v_fun(); <span class="comment">// B::v_fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯虚函数：</p><ul><li>纯虚函数在类中声明时，加上 =0；</li><li>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li><li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li></ul><p>说明：</p><ul><li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li><li>可以声明抽象类指针，可以声明抽象类的引用；</li><li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li></ul><h2 id="虚函数和纯虚函数的区别？"><a href="#虚函数和纯虚函数的区别？" class="headerlink" title="虚函数和纯虚函数的区别？"></a>虚函数和纯虚函数的区别？</h2><ul><li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）</li><li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li><li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 =0;</li><li>虚函数必须实现，否则编译器会报错；</li><li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li><li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li></ul><h2 id="虚函数的实现机制"><a href="#虚函数的实现机制" class="headerlink" title="虚函数的实现机制"></a>虚函数的实现机制</h2><p>实现机制：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数</p><p>虚函数表相关知识点：</p><ul><li>虚函数表存放的内容：类的虚函数的地址。</li><li>虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li><li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li></ul><p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p><p>实例：</p><p>无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derive();</span><br><span class="line">    p-&gt;B_fun1(); <span class="comment">// Base::B_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类和派生类的继承关系：</p><p><img src="/images/cpp_review_4.png" alt></p><p>基类的虚函数表：</p><p><img src="/images/cpp_review_5.png" alt></p><p>派生类的虚函数表：</p><p><img src="/images/cpp_review_6.png" alt></p><p>主函数中基类的指针 p 指向了派生类的对象，当调用函数 B_fun1() 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p><h2 id="单继承和多继承的虚函数表结构"><a href="#单继承和多继承的虚函数表结构" class="headerlink" title="单继承和多继承的虚函数表结构"></a>单继承和多继承的虚函数表结构</h2><p>编译器处理虚函数表：</p><ul><li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li><li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li><li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li><li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li></ul><p>单继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derive();</span><br><span class="line">    p-&gt;B_fun1(); <span class="comment">// Base::B_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类和派生类的继承关系：</p><p><img src="/images/cpp_review_7.png" alt></p><p>基类的虚函数表：</p><p><img src="/images/cpp_review_8.png" alt></p><p>派生类的虚函数表：</p><p><img src="/images/cpp_review_9.png" alt></p><p>单继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::B_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derive();</span><br><span class="line">    p-&gt;fun1(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类的虚函数表：</p><p><img src="/images/cpp_review_10.png" alt></p><p>多继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::B1_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::B1_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::B1_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::B2_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::B2_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::B2_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::B3_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::B3_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::B3_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base1 *p = <span class="keyword">new</span> Derive();</span><br><span class="line">    p-&gt;B1_fun1(); <span class="comment">// Base1::B1_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类和派生类的关系：</p><p><img src="/images/cpp_review_11.png" alt></p><p>派生类的虚函数表：（基类的顺序和声明的顺序一致）</p><p><img src="/images/cpp_review_12.png" alt></p><p>多继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::B1_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::B1_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::B2_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::B2_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::B3_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::B3_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::fun1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::D_fun3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base1 *p1 = <span class="keyword">new</span> Derive();</span><br><span class="line">    Base2 *p2 = <span class="keyword">new</span> Derive();</span><br><span class="line">    Base3 *p3 = <span class="keyword">new</span> Derive();</span><br><span class="line">    p1-&gt;fun1(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    p2-&gt;fun1(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    p3-&gt;fun1(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类和派生类的关系：</p><p><img src="/images/cpp_review_13.png" alt></p><p>派生类的虚函数表：</p><p><img src="/images/cpp_review_14.png" alt></p><h1 id="语言特性相关"><a href="#语言特性相关" class="headerlink" title="语言特性相关"></a>语言特性相关</h1><h2 id="左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？"><a href="#左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？" class="headerlink" title="左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？"></a>左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？</h2><p>左值：指表达式结束后依然存在的持久对象。</p><p>右值：表达式结束就不再存在的临时对象。</p><p>左值和右值的区别：左值持久，右值短暂</p><p>右值引用和左值引用的区别：</p><ul><li>左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</li><li>右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</li></ul><p>std::move 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span>&amp; tmp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun1(int&amp; tmp):"</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span>&amp;&amp; tmp)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun2(int&amp;&amp; tmp)"</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">11</span>; </span><br><span class="line">  fun1(<span class="number">12</span>); <span class="comment">// error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'</span></span><br><span class="line">  fun1(var);</span><br><span class="line">  fun2(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-move-函数的实现原理"><a href="#std-move-函数的实现原理" class="headerlink" title="std::move() 函数的实现原理"></a>std::move() 函数的实现原理</h2><p>std::move() 函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：引用折叠原理</p><ul><li>右值传递给上述函数的形参 T&amp;&amp; 依然是右值，即 T&amp;&amp; &amp;&amp; 相当于 T&amp;&amp;。</li><li>左值传递给上述函数的形参 T&amp;&amp; 依然是左值，即 T&amp;&amp; &amp; 相当于 T&amp;。</li></ul><p>小结：通过引用折叠原理可以知道，move() 函数的形参既可以是左值也可以是右值。</p><p>remove_reference 具体实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始的，最通用的版本</span></span><br><span class="line">template &lt;typename T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span></span>&#123;</span><br><span class="line">    typedef T <span class="class"><span class="keyword">type</span>;</span>  <span class="comment">//定义 T 的类型别名为 type</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//部分版本特例化，将用于左值引用和右值引用</span></span><br><span class="line">template &lt;class T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span></span>&lt;T&amp;&gt; <span class="comment">//左值引用</span></span><br><span class="line">&#123; typedef T <span class="class"><span class="keyword">type</span>;</span> &#125;</span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span></span>&lt;T&amp;&amp;&gt; <span class="comment">//右值引用</span></span><br><span class="line">&#123; typedef T <span class="class"><span class="keyword">type</span>;</span> &#125;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">//举例如下,下列定义的a、b、c三个变量都是int类型</span></span><br><span class="line">int i;</span><br><span class="line">remove_refrence&lt;decltype(<span class="number">42</span>)&gt;::<span class="class"><span class="keyword">type</span> <span class="title">a</span></span>;             <span class="comment">//使用原版本，</span></span><br><span class="line">remove_refrence&lt;decltype(i)&gt;::<span class="class"><span class="keyword">type</span>  <span class="title">b</span></span>;             <span class="comment">//左值引用特例版本</span></span><br><span class="line">remove_refrence&lt;decltype(std::<span class="keyword">move</span>(i))&gt;::<span class="class"><span class="keyword">type</span>  <span class="title">b</span></span>;  <span class="comment">//右值引用特例版本</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">转化过程：</span><br><span class="line"><span class="number">1.</span> <span class="built_in">std</span>::<span class="built_in">move</span>(var) =&gt; <span class="built_in">std</span>::<span class="built_in">move</span>(<span class="keyword">int</span>&amp;&amp; &amp;) =&gt; 折叠后 <span class="built_in">std</span>::<span class="built_in">move</span>(<span class="keyword">int</span>&amp;)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 此时：T 的类型为 <span class="keyword">int</span>&amp;，<span class="keyword">typename</span> remove_reference&lt;T&gt;::type 为 <span class="keyword">int</span>，这里使用 remove_reference 的左值引用的特例化版本</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 通过 <span class="keyword">static_cast</span> 将 <span class="keyword">int</span>&amp; 强制转换为 <span class="keyword">int</span>&amp;&amp;</span><br><span class="line"></span><br><span class="line">整个<span class="built_in">std</span>::<span class="built_in">move</span>被实例化如下</span><br><span class="line"><span class="built_in">string</span>&amp;&amp; <span class="built_in">move</span>(<span class="keyword">int</span>&amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br>std::move() 实现原理：</p><ul><li>利用引用折叠原理将右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp; 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；</li><li>然后通过 remove_refrence 移除引用，得到具体的类型 T；</li><li>最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 T&amp;&amp; 右值引用。</li></ul><h2 id="什么是指针？指针的大小及用法？"><a href="#什么是指针？指针的大小及用法？" class="headerlink" title="什么是指针？指针的大小及用法？"></a>什么是指针？指针的大小及用法？</h2><p>指针： 指向另外一种类型的复合类型。<br>指针的大小： 在 64 位计算机中，指针占 8 个字节空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针的用法：</p><p>指向普通对象的指针:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向常量对象的指针：常量指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;c_var;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向函数的指针：函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*fun_p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    fun_p = add;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fun_p(<span class="number">1</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。<br>特别注意：定义指向成员函数的指针时，要标明指针所属的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A ex;</span><br><span class="line">    ex.var1 = <span class="number">3</span>;</span><br><span class="line">    ex.var2 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;ex.var1; <span class="comment">// 指向对象成员变量的指针</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (A::*fun_p)();</span><br><span class="line">    fun_p = A::add; <span class="comment">// 指向对象成员函数的指针 fun_p</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ex.*fun_p)() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this 指针：指向类的当前对象的指针常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">string</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_sex</span><span class="params">(<span class="keyword">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sex = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Age: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sex: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;sex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> A();</span><br><span class="line">    p-&gt;set_name(<span class="string">"Alice"</span>);</span><br><span class="line">    p-&gt;set_age(<span class="number">16</span>);</span><br><span class="line">    p-&gt;set_sex(<span class="number">1</span>);</span><br><span class="line">    p-&gt;show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是野指针和悬空指针？<br>悬空指针： 若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line"><span class="comment">// 此时，p 指向的内存空间已释放， p 就是悬空指针。</span></span><br></pre></td></tr></table></figure><p>野指针：</p><p>“野指针”是指不确定其指向的指针，未初始化的指针为“野指针”。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p; </span><br><span class="line"><span class="comment">// 此时 p 是“野指针”。</span></span><br></pre></td></tr></table></figure><h2 id="C-11-nullptr-比-NULL-优势"><a href="#C-11-nullptr-比-NULL-优势" class="headerlink" title="C++ 11 nullptr 比 NULL 优势"></a>C++ 11 nullptr 比 NULL 优势</h2><ul><li>NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 中，即 #define NULL 0。</li><li>nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。</li></ul><p>nullptr 的优势：</p><ul><li>有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。</li><li>函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span> const *p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"fun(char const *p)"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> tmp)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">"fun(int tmp)"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>(<span class="title">nullptr</span></span>); <span class="regexp">//</span> <span class="function"><span class="keyword">fun</span>(<span class="title">char</span></span> const *p)</span><br><span class="line">    /*</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>(<span class="title">NULL</span></span>); <span class="regexp">//</span> <span class="symbol">error:</span> call <span class="keyword">of</span> overloaded <span class="string">'fun(NULL)'</span> is ambiguous</span><br><span class="line">    *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="指针和引用的区别？"><a href="#指针和引用的区别？" class="headerlink" title="指针和引用的区别？"></a>指针和引用的区别？</h2><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）</li><li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）</li><li>指针可以为空，但是引用必须绑定对象。（是否可为空）</li><li>指针可以有多级，但是引用只能一级。（是否能为多级）</li></ul><p>6.7 常量指针和指针常量的区别<br>常量指针：常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br>特点：const 的位置在指针声明运算符 <em>的左侧。只要 const 位于 </em>的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p;</span><br></pre></td></tr></table></figure><p>注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;c_var; </span><br><span class="line">    *p = <span class="number">6</span>;            <span class="comment">// error: assignment of read-only location '* p'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。<br>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var1 = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var2 = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;c_var1; </span><br><span class="line">    p = &amp;c_var2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针常量：<br>指针常量的本质上是个常量，只不过这个常量的值是一个指针。<br>特点：const 位于指针声明操作符右侧，表明该对象本身是一个常量，<em> 左侧表示该指针指向的类型，即以 </em>为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">var</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;<span class="keyword">var</span>;</span><br></pre></td></tr></table></figure><p>注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var, var1;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var;</span><br><span class="line">    c_p = &amp;var1; <span class="comment">// error: assignment of read-only variable 'c_p'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 2：指针的内容可以改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var;</span><br><span class="line">    *c_p = <span class="number">12</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针和指针函数的区别"><a href="#函数指针和指针函数的区别" class="headerlink" title="函数指针和指针函数的区别"></a>函数指针和指针函数的区别</h2><p>指针函数：<br>指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Type</span><br><span class="line">&#123;</span><br><span class="line">  int var1;</span><br><span class="line">  int var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Type * fun(int tmp1, int tmp2)&#123;</span><br><span class="line">   <span class="built_in"> Type </span>* t = new Type();</span><br><span class="line">    t-&gt;var1 = tmp1;</span><br><span class="line">    t-&gt;var2 = tmp2;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in"> Type </span>*p = fun(5, 6);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数指针：<br>函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。</p><p>举例：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int fun1(int tmp1, int tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tmp1 * tmp2;</span><br><span class="line">&#125;</span><br><span class="line">int fun2(int tmp1, int tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tmp1 / tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int (*<span class="function"><span class="keyword">fun</span>)(<span class="title">int</span></span> x, int y); </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> = <span class="title">fun1</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="function"><span class="keyword">fun</span>(15, 5) <span class="title">&lt;&lt;</span></span> endl; </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> = <span class="title">fun2</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="function"><span class="keyword">fun</span>(15, 5) <span class="title">&lt;&lt;</span></span> endl; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><p>函数指针和指针函数的区别：</p><ul><li>本质不同<br>1.指针函数本质是一个函数，其返回值为指针。<br>2.函数指针本质是一个指针变量，其指向一个函数。</li><li>定义形式不同<br>1.指针函数：int<em> fun(int tmp1, int tmp2); ，这里</em> 表示函数的返回值类型是指针类型。<br>2.函数指针：int (fun)(int tmp1, int tmp2);，这里 表示变量本身是指针类型。</li><li>用法不同</li></ul><h2 id="强制类型转换有哪几种？"><a href="#强制类型转换有哪几种？" class="headerlink" title="强制类型转换有哪几种？"></a>强制类型转换有哪几种？</h2><ul><li>static_cast：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。<br>1.用于基本数据类型的转换。<br>2.用于类层次之间的基类和派生类之间 指针或者引用 的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。<br>3.可以将空指针转化成目标类型的空指针。<br>4.可以将任何类型的表达式转化成 void 类型。</li><li>const_cast：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</li><li>reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。</li><li>dynamic_cast：<br>1.其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。<br>2.只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。<br>3.在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p1 = <span class="keyword">new</span> Derive();</span><br><span class="line">    Derive *p2 = <span class="keyword">new</span> Derive();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向上类型转换</span></span><br><span class="line">    p1 = <span class="keyword">dynamic_cast</span>&lt;Base *&gt;(p2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NOT NULL"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>4. 在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive::fun()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p1 = <span class="keyword">new</span> Derive();</span><br><span class="line">    Base *p2 = <span class="keyword">new</span> Base();</span><br><span class="line">    Derive *p3 = <span class="keyword">new</span> Derive();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换成功</span></span><br><span class="line">    p3 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(p1);</span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NOT NULL"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换失败</span></span><br><span class="line">    p3 = <span class="keyword">dynamic_cast</span>&lt;Derive *&gt;(p2);</span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NOT NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？"><a href="#如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？" class="headerlink" title="如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？"></a>如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？</h2><p>需要重载操作符 == 判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构体是否相等，因为 memcmp 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</p><p>利用运算符重载来实现结构体对象的比较：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    A(<span class="keyword">char</span> c_tmp, <span class="keyword">int</span> tmp) : c(c_tmp), val(tmp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> A &amp;tmp1, <span class="keyword">const</span> A &amp;tmp2); <span class="comment">//  友元运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> A &amp;tmp1, <span class="keyword">const</span> A &amp;tmp2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (tmp1.c == tmp2.c &amp;&amp; tmp1.val == tmp2.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex1</span>(<span class="params"><span class="string">'a'</span>, <span class="number">90</span></span>), <span class="title">ex2</span>(<span class="params"><span class="string">'b'</span>, <span class="number">80</span></span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (ex1 == ex2)</span><br><span class="line">        cout &lt;&lt; <span class="string">"ex1 == ex2"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"ex1 != ex2"</span> &lt;&lt; endl; <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数传递时，值传递、引用传递、指针传递的区别？"><a href="#参数传递时，值传递、引用传递、指针传递的区别？" class="headerlink" title="参数传递时，值传递、引用传递、指针传递的区别？"></a>参数传递时，值传递、引用传递、指针传递的区别？</h2><p>参数传递的三种方式：</p><ul><li>值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</li><li>指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</li><li>引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>&#123; <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> * tmp)</span></span>&#123; <span class="comment">// 指针传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">int</span> &amp;tmp)</span></span>&#123; <span class="comment">// 引用传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"var 在主函数中的地址："</span> &lt;&lt; &amp;var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"var 值传递时的地址："</span>;</span><br><span class="line">    fun1(var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"var 指针传递时的地址："</span>;</span><br><span class="line">    fun2(&amp;var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"var 引用传递时的地址："</span>;</span><br><span class="line">    fun3(var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">var 在主函数中的地址：0x23fe4c</span></span><br><span class="line"><span class="comment">var 值传递时的地址：0x23fe20</span></span><br><span class="line"><span class="comment">var 指针传递时的地址：0x23fe4c</span></span><br><span class="line"><span class="comment">var 引用传递时的地址：0x23fe4c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样，在函数体内操作的不是变量本身。引用传递和指针传递，在函数体内操作的是变量本身。</p><p>6.12 什么是模板？如何实现？<br>模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<br>实现方式：模板定义以关键字 template 开始，后跟一个模板参数列表。</p><ul><li>模板参数列表不能为空；</li><li>模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, ...&gt;</span><br></pre></td></tr></table></figure><p>函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。</p><ul><li>对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</li><li>函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add_fun</span><span class="params">(<span class="keyword">const</span> T &amp; tmp1, <span class="keyword">const</span> T &amp; tmp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; var1 &gt;&gt; var2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add_fun(var1, var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> var3, var4;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; var3 &gt;&gt; var4;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add_fun(var3, var4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Complex(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    Complex&lt;T&gt; <span class="keyword">operator</span>+(Complex &amp;c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c.a, <span class="keyword">this</span>-&gt;b + c.b)</span></span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp.a &lt;&lt; <span class="string">" "</span> &lt;&lt; tmp.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    Complex&lt;<span class="keyword">int</span>&gt; c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数模板和类模板的区别？"><a href="#函数模板和类模板的区别？" class="headerlink" title="函数模板和类模板的区别？"></a>函数模板和类模板的区别？</h2><ul><li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li><li>实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li><li>默认参数：类模板在模板参数列表中可以有默认参数。</li><li>特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</li><li>调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。</li></ul><p>函数模板调用方式举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add_fun</span><span class="params">(<span class="keyword">const</span> T &amp; tmp1, <span class="keyword">const</span> T &amp; tmp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; var1 &gt;&gt; var2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add_fun&lt;<span class="keyword">int</span>&gt;(var1, var2); <span class="comment">// 显式调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> var3, var4;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; var3 &gt;&gt; var4;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add_fun(var3, var4); <span class="comment">// 隐式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.14 什么是可变参数模板？<br>可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。</p><ul><li>模板参数包：表示零个或多个模板参数；</li><li>函数参数包：表示零个或多个函数参数。</li></ul><p>用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 sizeof… 运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="comment">// Args 是模板参数包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>; <span class="comment">// 可变参数模板，rest 是函数参数包</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_fun</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 最后一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_fun</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    print_fun(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_fun(<span class="string">"Hello"</span>, <span class="string">"wolrd"</span>, <span class="string">"!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">Hello wolrd !</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：可变参数函数通常是递归的，第一个版本的 print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print_fun 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值。</p><h2 id="什么是模板特化？为什么特化？"><a href="#什么是模板特化？为什么特化？" class="headerlink" title="什么是模板特化？为什么特化？"></a>什么是模板特化？为什么特化？</h2><p>模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。</p><p>模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化</p><ul><li>函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</li><li>类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</li></ul><p>特化分为全特化和偏特化：</p><ul><li>全特化：模板中的模板参数全部特例化。</li><li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li></ul><p>说明：要区分下函数重载与函数模板特化<br>定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare</span>(<span class="title">T</span> <span class="title">t1</span>, <span class="title">T</span> <span class="title">t2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"通用版本："</span>;</span><br><span class="line">    <span class="keyword">return</span> t1 == t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">//函数模板特化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">char</span> *t1, <span class="keyword">char</span> *t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"特化版本："</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(t1, t2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr1[] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> arr2[] = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; compare(<span class="number">123</span>, <span class="number">123</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; compare(arr1, arr2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">通用版本：1</span></span><br><span class="line"><span class="comment">特化版本：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="include-“-“-和-lt-gt-的区别"><a href="#include-“-“-和-lt-gt-的区别" class="headerlink" title="include “ “ 和 &lt;&gt; 的区别"></a>include “ “ 和 &lt;&gt; 的区别</h2><p>include&lt;文件名&gt; 和 #include”文件名” 的区别:</p><ul><li>查找文件的位置：include&lt;文件名&gt;在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；#include”文件名” 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</li><li>使用习惯：对于标准库中的头文件常用 include&lt;文件名&gt;，对于自己定义的头文件，常用 #include”文件名”</li></ul><h2 id="泛型编程如何实现？"><a href="#泛型编程如何实现？" class="headerlink" title="泛型编程如何实现？"></a>泛型编程如何实现？</h2><p>泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。</p><p>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</p><ul><li>容器：涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。</li><li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li><li>模板：可参考本章节中的模板相关问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于protobuf的配置系统</title>
      <link href="/posts/cd6cc41b.html"/>
      <url>/posts/cd6cc41b.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍一种基于protobuf实现的配置文件体系，提升配置文件使用体验，同时支持分环境加载不同配置。<br>本配置系统相对于json，支持配置中添加注释，方便理解；支持自动反序列化，操作简单，同时减少DOM操作不当造成的coredump。<br>本配置系统相对于yml等配置文件，支持自动反序列化；不会因为缩进问题造成解析失败。</p><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>基础使用的步骤包括proto定义、配置文件编写、服务引入三个环节。<br>首先是proto定义，参考下面定义一个proto:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">syntax</span>=<span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">message LogConfig &#123;</span><br><span class="line">  enum LogLevel &#123;</span><br><span class="line">    <span class="builtin-name">DEBUG</span> = 0;</span><br><span class="line">    NOTICE = 1;</span><br><span class="line">    <span class="builtin-name">WARNING</span> = 2;</span><br><span class="line">    <span class="builtin-name">ERROR</span> = 3;</span><br><span class="line">    FATAL = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  string path = 1;</span><br><span class="line">  LogLevel level = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ServiceConfig &#123;</span><br><span class="line">  string<span class="built_in"> config </span>= 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ServerConfig &#123;</span><br><span class="line">  uint32<span class="built_in"> port </span>= 1;</span><br><span class="line">  uint32 thread_num = 2;</span><br><span class="line">  LogConfig log_config = 3;</span><br><span class="line">  repeated ServiceConfig service_config = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是服务配置编写，例如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">port</span> : 8080</span><br><span class="line"><span class="selector-tag">thread_num</span>: 8</span><br><span class="line"><span class="selector-tag">log_config</span>: &#123;</span><br><span class="line">    <span class="attribute">path</span>: <span class="string">"./log"</span></span><br><span class="line">    level: NOTICE</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">service_config</span>: &#123;</span><br><span class="line">    <span class="attribute">config</span>: <span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是在服务中使用了，由于本配置体系依赖了protobuf、glog、gflags，使用时确保链接这三个库。</p><p>使用代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config_manager.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"configs/server_config.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">    google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> file = <span class="string">"../conf/server"</span>;</span><br><span class="line">    ServerConfig serverConfig;</span><br><span class="line">    ConfigManager::parse(file, &amp;serverConfig);</span><br><span class="line">    google::ShutdownGoogleLogging();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中配置路径不需要后缀，默认配置文件后缀为”*.conf”，也就是”../conf/server.conf”文件。<br>ServerConfig为目标配置反序列化之后的对象。</p><h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><p>这部分介绍用户可以根据自己的需要，针对不同环境使用不同的配置，例如prod、pre、test使用不同的配置文件，同时有一份基准配置，优先使用指定环境的配置，如果该配置未设置，使用基准配置覆盖。<br>使用gflag “env”确定加载哪份配置作为环境配置，默认是prod。<br>使用gflag “suffix”确定配置文件后缀，默认是”conf”。</p><p>例如，基准配置conf/server.conf是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">port</span> : 8080</span><br><span class="line"><span class="selector-tag">thread_num</span>: 8</span><br><span class="line"><span class="selector-tag">log_config</span>: &#123;</span><br><span class="line">    <span class="attribute">path</span>: <span class="string">"./log"</span></span><br><span class="line">    level: NOTICE</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">service_config</span>: &#123;</span><br><span class="line">    <span class="attribute">config</span>: <span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环境配置conf/server-prod.conf是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">port</span> : 80</span><br><span class="line"><span class="selector-tag">log_config</span>: &#123;</span><br><span class="line">    <span class="attribute">level</span>: WARNING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到的合并配置为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">port</span>: 80 </span><br><span class="line"><span class="selector-tag">thread_num</span>: 8 </span><br><span class="line"><span class="selector-tag">log_config</span> &#123; </span><br><span class="line">    <span class="attribute">path</span>: <span class="string">"./log"</span> </span><br><span class="line">    level: WARNING </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">service_config</span> &#123; </span><br><span class="line">    <span class="attribute">config</span>: <span class="string">"123"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果一个字段是repeated时，如果环境配置没有设置，就使用基准配置的；如果环境配置设置了，就不会使用基准配置了。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="文本配置解析"><a href="#文本配置解析" class="headerlink" title="文本配置解析"></a>文本配置解析</h2><p>基于protobuf的文本配置，利用的是<code>google/protobuf/text_format.h</code>文件中的<code>google::protobuf::TextFormat::Parse</code>函数，其功能是将文本内容反序列化为message内容。<br>这个函数其实是<code>google::protobuf::Message</code>的<code>DebugString</code>函数的逆操作。</p><p>解析的代码如下:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> file = open(path.c_str(), O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (file &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">google:</span>:<span class="string">protobuf:</span>:<span class="string">io:</span>:FileInputStream reader&#123;file&#125;;</span><br><span class="line">reader.SetCloseOnDelete(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">google:</span>:<span class="string">protobuf:</span>:<span class="string">TextFormat:</span>:Parse(&amp;reader, msg)) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="配置合并"><a href="#配置合并" class="headerlink" title="配置合并"></a>配置合并</h2><p>protobuf提供了MergeFrom函数支持两个Message对象进行合并，对于repeated的结构，合并后的结果是这两个结构的并集。<br>这个情况是不符合预期的，例如Message里有a字段是repeated的，合并结果如下:</p><table><thead><tr><th>A 配置中a字段元素数量</th><th>B配置中a字段元素数量</th><th>合并结果</th></tr></thead><tbody><tr><td>2</td><td>0</td><td>2(全部来自A)</td></tr><tr><td>0</td><td>2</td><td>2(全部来自B)</td></tr><tr><td>2</td><td>3</td><td>2(全部来自A)</td></tr></tbody></table><p>针对这样的需求，不能直接使用MergeFrom函数，需要使用protobuf的反射能力进行逐一赋值。</p><p>代码有点长，可以参考<a href="https://github.com/phantom9999/mithril/blob/main/pb_base_conf/src/config_manager.cpp#L49" target="_blank" rel="noopener">代码</a>。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用jeprof定位内存泄漏</title>
      <link href="/posts/361305b0.html"/>
      <url>/posts/361305b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将介绍基于jeprof定位内存泄漏问题，支持缓慢内存泄漏场景、瞬间oom场景等。</p><h2 id="jeprof介绍"><a href="#jeprof介绍" class="headerlink" title="jeprof介绍"></a>jeprof介绍</h2><p>jeprof是jemalloc提供的一个内存优化的工具，jemalloc是facebook开源的内存管理工具，类似ptmalloc和tcmalloc，在多线程场景具有较好的性能。<br>默认情况下编译jemalloc后并没有jeprof工具，需要在编译时添加<code>–enable-prof</code>参数，然后在编译目录的bin目录中就能找到jeprof程序。<br>开启prof功能的jemalloc根据环境变量MALLOC_CONF和mallctl接口操作prof功能。<br>MALLOC_CONF变量接收的参数参考<a href="http://jemalloc.net/jemalloc.3.html" target="_blank" rel="noopener">jemalloc prof功能</a>。</p><h1 id="缓慢内存泄漏定位方案"><a href="#缓慢内存泄漏定位方案" class="headerlink" title="缓慢内存泄漏定位方案"></a>缓慢内存泄漏定位方案</h1><p>这个方案适用于服务内存泄漏不是特别快，从服务启动完毕到oom的时间大于30秒以上，开发者有充足的时间去触发dump。<br>这个方案是在服务中添加dump接口，然后让开发在服务启动完毕(数据字典、索引加载完毕)后，触发一次dump，然后刷一定流量后，再触发一次dump，对比两次dump前后内存差，确定内存泄漏的位置。</p><p>需要注意的是，这种方法一定要服务启动完毕，不然服务启动过程中加载的数据就会在diff结果中，影响判断。<br>其次，这种方法需要要求开发者把服务里的cache关闭，cache的存在也会影响diff结果的判断。</p><h2 id="示例服务介绍"><a href="#示例服务介绍" class="headerlink" title="示例服务介绍"></a>示例服务介绍</h2><p>示例服务是一个基于beast开发的一个webservice，使用cmake构建，使用conan管理依赖，代码可以在<a href="https://github.com/phantom9999/mithril/tree/main/jeprof_in_use" target="_blank" rel="noopener">github地址</a>上找到。<br>这个webservice提供两个接口，一个是正常返回数据的接口，一个是内存泄漏的接口。内存泄漏的接口用于模拟内存泄漏的场景。<br>采用http协议的服务是因为http服务测试起来方便，不需要手写客户端。</p><p>项目的conan配置(conanfile.txt)内容如下:<br></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">build_requires</span>]</span><br><span class="line"></span><br><span class="line">[<span class="meta">requires</span>]</span><br><span class="line">boost/<span class="number">1.77</span><span class="number">.0</span></span><br><span class="line">jemalloc/<span class="number">5.2</span><span class="number">.1</span></span><br><span class="line">glog/<span class="number">0.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">generators</span>]</span><br><span class="line">cmake</span><br><span class="line"></span><br><span class="line">[<span class="meta">options</span>]</span><br><span class="line">jemalloc:enable_prof=True</span><br></pre></td></tr></table></figure><p></p><p>beast是boost中的一个库，glog是日志库，下文用来分析内存泄漏的工具jeprof在jemalloc库中，需要注意的是options中jemalloc的prof已经要手工开启，默认是不开启的。</p><p>这个webservice参考beast的“高级服务器”代码实现的，正常的接口的路径是“/”，逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">HttpSession::processNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"visit"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"use http://www.webgraphviz.com/ "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其功能就是打个日志，然后输出一句话。</p><p>内存泄漏的接口路径为”/leak”，其逻辑如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">HttpSession::processLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span>* leak = <span class="keyword">new</span> <span class="keyword">int32_t</span>[<span class="number">1024</span>*<span class="number">256</span>];</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"leak address "</span> &lt;&lt; leak;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"memory leak"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口调用一次就泄漏1MB的内存。</p><p>这个项目编译运行的步骤:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 创建编译目录</span></span><br><span class="line">mkdir build;</span><br><span class="line">cd build;</span><br><span class="line"><span class="meta"># 使用conan安装依赖</span></span><br><span class="line">conan install ..</span><br><span class="line"><span class="meta"># 使用cmake构建</span></span><br><span class="line">cmake ..</span><br><span class="line"><span class="meta"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta"># 运行</span></span><br><span class="line">./bin/server</span><br></pre></td></tr></table></figure><h2 id="dump接口开发"><a href="#dump接口开发" class="headerlink" title="dump接口开发"></a>dump接口开发</h2><p>对于一些泄漏缓慢服务，使用定量dump的方式只会带来一堆的dump文件或者连dump文件都没有，影响泄漏定位效率。<br>为此，需要一种简单的手工触发dump的方式来协助定位内存泄漏。</p><p>在现有服务中，添加一个手工触发dump的接口，即在新的接口里调用jemalloc的dump函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mallctl(<span class="string">"prof.dump"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>mallctl函数是操作调用函数，”prof.dump”是进行内存情况dump操作。</p><p>实际代码可以参考<a href="https://github.com/phantom9999/mithril/blob/main/jeprof_in_use/src/http_session.cpp" target="_blank" rel="noopener">github代码</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">HttpSession::processDump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mallctl(<span class="string">"prof.dump"</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"dump sucess"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dump success"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"dump sucess"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dump fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面接口为”/dump”。</p><h2 id="接口使用与数据分析"><a href="#接口使用与数据分析" class="headerlink" title="接口使用与数据分析"></a>接口使用与数据分析</h2><p>服务启动前设置环境变量<code>MALLOC_CONF=’prof:true,prof_prefix:jemalloc’</code> 开启prof功能。</p><p>服务启动并加载完数据后，调用dump接口生成一份基准的内存分析数据，在本例子中，使用下面命令即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 'http://localhost:8080/dump';</span><br></pre></td></tr></table></figure><p>然后调用内存泄漏的接口，模拟内存泄漏，命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 'http://localhost:8080/leak';</span><br></pre></td></tr></table></figure><p>多次调用内存泄漏的接口之后，再次调用dump接口，生成第二份内存分析数据。这时我们得到了两份数据，第一份是基准，文件名是“jemalloc.10391.0.m0.heap”，第二份是“jemalloc.10391.1.m1.heap”。接着我们使用jeprof工具来分析这两份数据，jeprof可以从conan下载的jemalloc中找到，命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jeprof --dot ./bin/server --base=jemalloc.10391.0.m0.heap jemalloc.10391.1.m1.heap</span><br></pre></td></tr></table></figure><p>终端中会输出dot语法的图，将其贴到<a href="http://www.webgraphviz.com/" target="_blank" rel="noopener">在线dot绘图网站</a>，生成内存分配图，然后进行分析。</p><p>样例数据可以在<a href="/images/jeprof_file.txt">这里</a>找到，生成的图如下:</p><p><img src="/images/jeprof_img.png" alt></p><p>从图中可以看到，两个快照比较多余部分（泄漏部分）的内存在”processLeak”函数中。</p><h1 id="快速oom定位方案"><a href="#快速oom定位方案" class="headerlink" title="快速oom定位方案"></a>快速oom定位方案</h1><p>有时候某个流量触发了服务中的一个死循环，然后死循环里会申请内存，但这份内存需要在循环外的其他地方才会释放。<br>这时，服务就会出现瞬间oom的情况，速度之快，无法人工dump。</p><p>面对这种情况，就要开启定量dump和推出dump，需要的参数如下:</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>prof:true</td><td>启动profile</td></tr><tr><td>prof_final:true</td><td>表示退出时prof</td></tr><tr><td>lg_prof_interval:N</td><td>每流转 1 « N 个字节，将采样统计数据转储到文件</td></tr><tr><td>prof_gdump:true</td><td>打到新高dump</td></tr><tr><td>prof_active:false</td><td>不激活，用于手工激活</td></tr><tr><td>lg_prof_sample:N</td><td>平均每分配出 2^N 个字节 采一次样。当 N = 0 时，意味着每次分配都采样</td></tr></tbody></table><p>备注: lg_prof_sample是分配计数的采样频率，lg_prof_interval是分配统计，只有被计数了才会被打印。</p><p>建议的prof环境变量设置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">MALLOC_CONF</span>=<span class="string">"prof_leak:true,lg_prof_sample:0,prof_final:true;lg_prof_interval:30"</span></span><br></pre></td></tr></table></figure><p>每分配1GB内存就打印一份数据，并且在服务退出时，也同时dump一份。<br>然后比较每份dump的数据的diff确认内存泄漏的位置。</p><p>需要注意的是，这种方法也没法处理cache问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://jemalloc.net/jemalloc.3.html" target="_blank" rel="noopener">jemalloc prof功能</a></li><li><a href="http://www.webgraphviz.com/" target="_blank" rel="noopener">dot可视化</a></li><li><a href="https://www.yuanguohuo.com/2019/01/02/jemalloc-heap-profiling/" target="_blank" rel="noopener">jemalloc的heap profiling</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> jemalloc </tag>
            
            <tag> jeprof </tag>
            
            <tag> boost </tag>
            
            <tag> memory leak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于CLion远程开发</title>
      <link href="/posts/fa9b04c2.html"/>
      <url>/posts/fa9b04c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍基于docker和projector搭建一套c++的开发环境，提升研发效率问题。大多数c++服务是运行在linux平台的，代码也只能在linux上编译，但大部分开发者使用的是macbook或者thinkpad，很少用linux开发。开发环境、编译运行环境两边代码同步影响研发效率。<br>隔壁的vscode通过remote插件，支持远程开发模式，一定程度上提升了研发效率。<br>年初Jetbrains开源的projector_install项目，旨在让IDE运行在服务端，然后本地通过网络与其交互。<br>本文将介绍这个环境的搭建。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>有vps或者linux开发机的同学，可以参考dockerfile进行安装。没有vps或<br>者linux开发机的同学，可以在macbook或者thinkpad上安装一个docker，然后使用下面dockerfile进行安装。<br>Dockerfile内容如下:<br></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本开发环境</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dnf install -y gcc-c++ cmake make git sudo; \</span></span><br><span class="line"><span class="bash">    dnf clean all; \</span></span><br><span class="line"><span class="bash">    rm -rf /var/cache/dnf/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python环境</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dnf install -y python3 python3-pip python3-pyOpenSSL python3-cryptography \</span></span><br><span class="line"><span class="bash">    less libXext libXrender libXtst libXi freetype; \</span></span><br><span class="line"><span class="bash">    dnf clean all; \</span></span><br><span class="line"><span class="bash">    rm -rf /var/cache/dnf/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户及目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> useradd -b /home -m -s /bin/bash work</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home/work</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> usermod -a -G wheel work</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"work:work"</span>|chpasswd </span></span><br><span class="line"><span class="keyword">USER</span> work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装projector和conan</span></span><br><span class="line"><span class="comment">## 更新pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python3 -m pip install -U pip --user; pip3 cache purge;</span></span><br><span class="line"><span class="comment">## 安装projector_install和conan</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install projector-installer conan --user; pip3 cache purge;</span></span><br><span class="line"><span class="comment">## 手工初始化目录，否则启动的时候需要协议确认</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p .projector/apps .projector/cache .projector/configs</span></span><br><span class="line"><span class="comment">## 安装IDE</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> .<span class="built_in">local</span>/bin/projector autoinstall --config-name CLion --ide-name <span class="string">"CLion 2021.2.3"</span> --port 9999; \</span></span><br><span class="line"><span class="bash">    rm .projector/cache/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口号</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"/home/work/.local/bin/projector"</span>, <span class="string">"run"</span>, <span class="string">"CLion"</span> ]</span></span><br></pre></td></tr></table></figure><p></p><p>然后执行下面命令进行镜像构建及推送:<br></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t phantom9999/projector:<span class="built_in">v1</span> .</span><br><span class="line"><span class="symbol">docker</span> <span class="keyword">push </span>phantom9999/projector:<span class="built_in">v1</span></span><br></pre></td></tr></table></figure><p></p><p>最后执行下面的命令启动容器:<br></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 9999:9999 phantom9999/projector:v1</span></span><br></pre></td></tr></table></figure><p></p><p>懒得自己构建镜像的同学，可以直接从docker hub上拉对应的镜像(虽然有点大):<br></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> pull phantom9999/projector:<span class="built_in">v1</span></span><br></pre></td></tr></table></figure><p></p><p>Jetbrains也提供了对应的镜像(系统是ubuntu的)，可以在<a href="https://hub.docker.com/u/jetbrains" target="_blank" rel="noopener">docker hub上找到</a>。</p><h1 id="环境使用"><a href="#环境使用" class="headerlink" title="环境使用"></a>环境使用</h1><p>在jetbrains的网站上找到<a href="https://lp.jetbrains.com/projector/" target="_blank" rel="noopener">projector工具</a>，下载native app，然后连接上云端的CLion即可。</p><p>projector貌似是专门优化的windows，在windows上操作无误，但是在mac系统上，稍稍有点小问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文使用的代码及命令可以在github的<a href="https://github.com/phantom9999/mithril/tree/main/projector_in_docker" target="_blank" rel="noopener">代码库</a>上找到。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetbrains </tag>
            
            <tag> CLion </tag>
            
            <tag> docker </tag>
            
            <tag> projector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abseil_intra</title>
      <link href="/posts/8ee50b98.html"/>
      <url>/posts/8ee50b98.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>folly_intra</title>
      <link href="/posts/71ae45ce.html"/>
      <url>/posts/71ae45ce.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> folly </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bazel使用文档</title>
      <link href="/posts/3ca09cc4.html"/>
      <url>/posts/3ca09cc4.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>bazel是google开源的构建系统，支持多种语言、支持云端构建等功能。</p><p>bazel与cmake、autoconf不太一样，bazel进行构建时会启动一个服务，然后bazel命令与这个服务进行交互发送指令，这个服务实际进行编译任务。同时bazel提供了一套远程构建、缓存的接口，实现这套接口就可以制定自己的远程构建系统了。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>bazel构建工具依赖java和python，bazel启动的构建服务是java开发的，bazel使用的构建配置是基于python写的，因此这两个组件并不可少。</p><p>bazel安装可以参考bazel提供的<a href="https://docs.bazel.build/versions/3.7.0/install-redhat.html" target="_blank" rel="noopener">安装教程</a></p><p>bazel支持远程方案，包括<a href="https://docs.bazel.build/versions/3.7.0/remote-execution.html" target="_blank" rel="noopener">远程构建</a>和<a href="https://docs.bazel.build/versions/3.7.0/remote-caching.html" target="_blank" rel="noopener">构建缓存</a>。</p><p><a href="https://github.com/bazelbuild/bazel-buildfarm" target="_blank" rel="noopener">buildform</a>是其中一种解决方案，buildform基于java编写，分为调度服务和工作服务，支持多分片部署，详细文档可以见buildform的<a href="https://github.com/bazelbuild/bazel-buildfarm/wiki" target="_blank" rel="noopener">wiki</a>。buildform的readme里有两个服务的简单启动命令，在examples目录下有对应的服务配置，使用对应的配置即可启动。</p><p>上面的环境部署好了之后，添加bazel的配置，bazel配置分为用户级别和项目级别，文件名为.bazel。添加下面内容，并在构建时添加 –config=build 即可实现远程编译:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Remote Build Execution requires a strong hash function, such as SHA256.</span></span><br><span class="line">startup <span class="attribute">--host_jvm_args</span>=-Dbazel.DigestFunction=SHA256</span><br><span class="line"></span><br><span class="line"><span class="comment"># Depending on how many machines are in the remote execution instance, setting</span></span><br><span class="line"><span class="comment"># this higher can make builds faster by allowing more jobs to run in parallel.</span></span><br><span class="line"><span class="comment"># Setting it too high can result in jobs that timeout, however, while waiting</span></span><br><span class="line"><span class="comment"># for a remote machine to execute them.</span></span><br><span class="line">build:remote <span class="attribute">--jobs</span>=8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set various strategies so that all actions execute remotely. Mixing remote</span></span><br><span class="line"><span class="comment"># and local execution will lead to errors unless the toolchain and remote</span></span><br><span class="line"><span class="comment"># machine exactly match the host machine.</span></span><br><span class="line">build:remote <span class="attribute">--spawn_strategy</span>=remote</span><br><span class="line">build:remote <span class="attribute">--strategy</span>=Javac=remote</span><br><span class="line">build:remote <span class="attribute">--strategy</span>=Closure=remote</span><br><span class="line">build:remote <span class="attribute">--genrule_strategy</span>=remote</span><br><span class="line">build:remote <span class="attribute">--define</span>=EXECUTOR=remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable the remote cache so action results can be shared across machines,</span></span><br><span class="line"><span class="comment"># developers, and workspaces.</span></span><br><span class="line">build:remote <span class="attribute">--remote_cache</span>=localhost:8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable remote execution so actions are performed on the remote systems.</span></span><br><span class="line">build:remote <span class="attribute">--remote_executor</span>=localhost:8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable encryption.</span></span><br><span class="line"><span class="comment">#build:remote --tls_enabled=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enforce stricter environment rules, which eliminates some non-hermetic</span></span><br><span class="line"><span class="comment"># behavior and therefore improves both the remote cache hit rate and the</span></span><br><span class="line"><span class="comment"># correctness and repeatability of the build.</span></span><br><span class="line">build:remote <span class="attribute">--experimental_strict_action_env</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a higher timeout value, just in case.</span></span><br><span class="line">build:remote <span class="attribute">--remote_timeout</span>=3600</span><br><span class="line"></span><br><span class="line">build:remote <span class="attribute">--auth_enabled</span>=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Since we're testing remote execution, let's make sure it always actually</span></span><br><span class="line"><span class="comment"># happens.</span></span><br><span class="line">build:remote <span class="attribute">--remote_accept_cached</span>=<span class="literal">false</span></span><br><span class="line">test <span class="attribute">--cache_test_results</span>=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">test <span class="attribute">--test_output</span>=errors</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO(b/77217487): Needed for C++ builds until fix to</span></span><br><span class="line"><span class="comment"># https://github.com/bazelbuild/bazel/issues/4883 is available.</span></span><br><span class="line">build --nocheck_visibility</span><br><span class="line"></span><br><span class="line">build:<span class="builtin-name">debug</span> --verbose_failures</span><br><span class="line">build:<span class="builtin-name">debug</span> <span class="attribute">--explain</span>=explain.txt</span><br><span class="line">build:<span class="builtin-name">debug</span> --verbose_explanations</span><br><span class="line">build:<span class="builtin-name">debug</span> --toolchain_resolution_debug</span><br><span class="line">build:<span class="builtin-name">debug</span> --subcommands</span><br></pre></td></tr></table></figure><p>在mac上使用bazel构建linux产物的方法的讨论在： <a href="https://stackoverflow.com/questions/61567876/bazel-mixing-a-linux-remote-execution-platform-with-a-mac-os-local-platform" target="_blank" rel="noopener">https://stackoverflow.com/questions/61567876/bazel-mixing-a-linux-remote-execution-platform-with-a-mac-os-local-platform</a> 目前还没有实现。</p><p>bazel平台的概念可以参考文档<a href="https://cloud.tencent.com/developer/article/1677379" target="_blank" rel="noopener">Bazel自定义工具链</a>。</p><h1 id="构建简单项目"><a href="#构建简单项目" class="headerlink" title="构建简单项目"></a>构建简单项目</h1><h1 id="使用复杂依赖管理"><a href="#使用复杂依赖管理" class="headerlink" title="使用复杂依赖管理"></a>使用复杂依赖管理</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>autofdo调研</title>
      <link href="/posts/1493c0ff.html"/>
      <url>/posts/1493c0ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="autoFDO调研"><a href="#autoFDO调研" class="headerlink" title="autoFDO调研"></a>autoFDO调研</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><h2 id="复杂案例"><a href="#复杂案例" class="headerlink" title="复杂案例"></a>复杂案例</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://gcc.gnu.org/wiki/AutoFDO/Tutorial" target="_blank" rel="noopener">gcc autoFDO教程</a></li><li><a href="https://blog.csdn.net/zhou1519/article/details/84139570" target="_blank" rel="noopener">gcc autoFDO教程 翻译</a></li><li><a href="https://github.com/google/autofdo" target="_blank" rel="noopener">autoFDO代码库</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options" target="_blank" rel="noopener">gcc 优化参数</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些c++库的使用总结</title>
      <link href="/posts/b945c282.html"/>
      <url>/posts/b945c282.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍一些c++库的使用。</p><h1 id="gflags"><a href="#gflags" class="headerlink" title="gflags"></a>gflags</h1><h2 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h2><p>gflags是一个流行的解析命令行的c++库。用户使用这个库定义的变量，可以通过多种途径进行赋值。</p><p>gflags支持定义多种数据类型，包括bool、int32、int64、uint64、double、string。</p><p>定义一个变量的操作如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_bool(<span class="name">name</span>, <span class="string">"default value"</span>, description)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后在main函数开头添加<code>google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</code>，在main函数末尾添加<code>google::ShutDownCommandLineFlags();</code>。</p><p>如果需要使用一个已经定义过的flags变量，则需要使用<code>DECLARE_XXX</code>，否则将会提示没有申明过这个变量。</p><p>gflags提供参数校验器，使用RegisterFlagValidator函数注册校验器。</p><p>gflags提供google::SetVersionString()函数设置版本信息(—version时返回的字符)。</p><p>gflags提供gflags::SetUsageMessage函数设置帮助信息（—help时返回的字符）。</p><p>gflags提供–flagfile参数指定配置文件，gflags将从这个配置文件中读取配置信息，同时，这个配置文件中也支持—flagfile读取配置。</p><p>gflags提供—fromenv参数从环境变量中读取配置信息。</p><h2 id="编译实用"><a href="#编译实用" class="headerlink" title="编译实用"></a>编译实用</h2><p>gflags一个比较坑的地方是，默认情况下gflags库的namespace是flags，而一大批依赖这个库的第三方库使用的google名字空间下的gflags。为了解决这个问题，需要在编译时指定名字空间（添加参数-DGFLAGS_NAMESPACE=google)。</p><p>有时候可能把gflags链接到动态链接库中，编译时的flags需要添加-fPIC，解决方法是在gflags中找到CMakeLists.txt中添加add_compile_options(-fPIC) 。</p><p>默认情况下gflags使用Release编译的，为了方便调试，建议设置-DCMAKE_BUILD_TYPE=RelWithDebInfo，即设置-o2 -g</p><h1 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>它是一个使用方便的日志库，这个库是一个带buffer的同步日志，不宜打太大的日志，也不宜打请求级别的日志。<br>如果需要打请求级别的日志，还是需要换成其他异步日志。</p><p>使用起来极其方便，包含头文件(glog/logging.h)，然后直接使用。</p><p>需要注意的是，FATAL日志会出core。</p><p>glog支持DLOG功能，这类日志在添加NDEBUG下不会打印DLOG日志，在没有这个flag下会打印这个日志，方便用户调试。</p><p>glog支持VLOG功能，这类日志划分为多个级别，通过命令行参数控制打印的级别。</p><p>使用时，在main函数开始添加google::InitGoogleLogging(argv[0]);开启使用glog之旅。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>glog依赖gflags库，使用glog的话建议先安装一下gflags，同时名字空间设置成google。</p><p>编译glog之前，先指定gflags路径，使用参数CMAKE_INCLUDE_PATH和CMAKE_LIBRARY_PATH完成。</p><h1 id="rocksdb"><a href="#rocksdb" class="headerlink" title="rocksdb"></a>rocksdb</h1><p>一个内嵌kv存储，常被用做各种分布式kv存储系统。<br>它也可以用来简单存个数据，做个二级存储啥的，作为一次存储性能还是不够的，毕竟跳表的性能没法跟哈希表比。</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>这个库依赖flags，所以编译前可以指定一下gflags，并添加参数-DWITH_GFLAGS=1指定依赖flags。</p><h1 id="fruit"><a href="#fruit" class="headerlink" title="fruit"></a>fruit</h1><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>这是一个基于元编程实现的依赖注入库。</p><h2 id="编译-2"><a href="#编译-2" class="headerlink" title="编译"></a>编译</h2><p>这个库依赖boost，编译时需要指定boost的目录，使用参数-DBoost_INCLUDE_DIR=指定boost位置。</p><p>这个库编译时建议添加-DBUILD_SHARED_LIBS=OFF关闭动态链接库。</p><h1 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h1><p>老牌的序列化、反序列化工具，常被用于各种rpc框架，数据传输等。<br>除此之外:</p><ul><li>可以序列化json。配合阿波罗实现一套强大的在线配置系统</li><li>文本格式。一套简单实用的配置系统</li></ul><p>需要注意的是，基于bazel构建时默认开启编译优化；如果使用autogen.sh + configure构建时，需要手工添加”O2 -g”，不然就没开优化。</p><h1 id="folly"><a href="#folly" class="headerlink" title="folly"></a>folly</h1><p>facebook开源的重量级库，极大的补充了c++的“基础设施”。<br>不足点，依赖比较多，编译起来比较费劲。</p><h1 id="abseil"><a href="#abseil" class="headerlink" title="abseil"></a>abseil</h1><p>google开源的，对c++stl的补充，功能较少，更多的是兼容语言特性，让c++11标准下用上c++17、c++20的特性。<br>不足之处，代码不多，静态库一大堆，建议使用bazel或者cmake的find_package进行依赖打平，不然解决依赖问题就够麻烦的了。</p><h1 id="boost"><a href="#boost" class="headerlink" title="boost"></a>boost</h1><p>c++ stl的补充，stl的候选集。<br>与folly、abseil相比，功能上 folly &gt; boost &gt; abseil，性能上folly = abseil &gt; boost。<br>编译安装、链接这块相对于folly、abseil容易。</p><h1 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h1><p>字符串格式化库，部分已经进入c++20，纯头文件。</p><h1 id="catch2"><a href="#catch2" class="headerlink" title="catch2"></a>catch2</h1><p>单侧库，纯头文件，编译起来慢。</p><h1 id="poco"><a href="#poco" class="headerlink" title="poco"></a>poco</h1><p>面向应用的库，各种常用中间件、工具封装都有，不过性能一般，没在生产环境使用过。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> lib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asio_multithread</title>
      <link href="/posts/aef5c1c6.html"/>
      <url>/posts/aef5c1c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>boost.asio是boost中的一个基于事件的网络库。本文将介绍asio的多线程模型。<br>asio有两种支持多线程的方案：方案一，开启一个线程池，每个线程独占一个io_context，并在各自的线程中运行io_context的run方法；方案二，开启一个线程池，并创建一个全局的io_context，在每个线程中调用io_context的run方法。<br>备注：新版本的asio使用io_context代替io_servvice。</p><h1 id="多io-context方案"><a href="#多io-context方案" class="headerlink" title="多io_context方案"></a>多io_context方案</h1><p>在这个多线程方案中，每个线程拥有一个io_context对象，同一个socket不会在多线程中共享，因此不需要引入同步机制。针对io型服务来说，io_context的数量应与cpu数量保持一致；针对计算型服务，请求阻塞了当前线程，当前线程将无法处理其他事件。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>接着我们来讲一讲这个方案的实现。<br>为了实现线程池中每个线程拥有一个io_context对象，我们需要先实现一个context池，然后供线程池和其他操作使用。幸运的是，asio代码库的example中提供了这样一个<a href="https://github.com/boostorg/asio/tree/develop/example/cpp03/http/server2" target="_blank" rel="noopener">例子</a>。io_context_pool类即是上文提到的context池，其申明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">io_context_pool</span> :</span> <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">io_context_pool</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> pool_size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  boost::<span class="function">asio::io_context&amp; <span class="title">get_io_context</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;boost::asio::io_context&gt; io_context_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> boost::asio::executor_work_guard&lt;</span><br><span class="line">    boost::asio::io_context::executor_type&gt; io_context_work;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;io_context_ptr&gt; io_contexts_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;io_context_work&gt; work_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> next_io_context_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类中提供了三个方法：</p><ul><li>run方法，创建线程池并在每个线程中运行io_context的run方法</li><li>stop方法，停用所有io_context</li><li>get_io_context方法，使用roundrobin算法获取io_context对象</li></ul><p>接着io_context_pool类对象作为server类的成员变量，在start_accept函数和构造函数中使用。server类的声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span> :</span> <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">server</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; port, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; doc_root, <span class="built_in">std</span>::<span class="keyword">size_t</span> io_context_pool_size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_stop</span><span class="params">()</span></span>;</span><br><span class="line">  io_context_pool io_context_pool_;</span><br><span class="line">  boost::asio::signal_set signals_;</span><br><span class="line">  boost::asio::ip::tcp::acceptor acceptor_;</span><br><span class="line">  connection_ptr new_connection_;</span><br><span class="line">  request_handler request_handler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="共享io-context方案"><a href="#共享io-context方案" class="headerlink" title="共享io_context方案"></a>共享io_context方案</h1><p>这种方案先创建一个全局的io_context对象，然后开启线程池，在每个线程中调用io_context的run方法。当出现异步事件时，io_context对象会将事件句柄交付给任意线程进行处理。这时io_context不会被某个事件阻塞，但多个线程共享事件循环可能导致socket描述符被多个线程共享，引起竞态条件，为此需要使用asio提供的strand方法来解决io问题。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>这个方案实现起来相对简单，不再需要实现context池，只需要实现一个线程池，并在线程池中执行io_context的run方法即可。在asio库中包含了这个<a href="https://github.com/boostorg/asio/tree/develop/example/cpp03/http/server3" target="_blank" rel="noopener">例子</a>，在线程池中运行全局的io_context的run方法。</p><p>server类的声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span> :</span> <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">server</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; port, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; doc_root, <span class="built_in">std</span>::<span class="keyword">size_t</span> thread_pool_size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_stop</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> thread_pool_size_;</span><br><span class="line">  boost::asio::io_context io_context_;</span><br><span class="line">  boost::asio::signal_set signals_;</span><br><span class="line">  boost::asio::ip::tcp::acceptor acceptor_;</span><br><span class="line">  connection_ptr new_connection_;</span><br><span class="line">  request_handler request_handler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从server类的声明中可以看到，全局的io_context对象存储在io_context_变量中，并在run函数和构造函数中进行使用。</p><h1 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h1><p>上面讲了两种方案的实现，这一节做一个简单的性能测试。<br>asio的example提供的两个server实现了基本的http server，本次用于测试的客户端使用brpc的http客户端，进行测试的serer开启六个个线程。这是本次性能测试使用的<a href="https://github.com/phantom9999/asio_benchmarks" target="_blank" rel="noopener">代码库</a>。<br>测试结果显示，这两种方案的峰值qps都在2w左右，性能差不多。<br>这两个server都会进行文件读写操作，一定程度上影响了测试结果，且本文使用的代码并没有进行优化，这也可能无法正确区分两种方案的性能差异。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="The Boost C++ Libraries Chapter 32. Boost.Asio">The Boost C++ Libraries Chapter 32. Boost.Asio</a></li><li><a href="https://www.gamedev.net/blogs/entry/2249317-a-guide-to-getting-started-with-boostasio/" target="_blank" rel="noopener">A guide to getting started with boost::asio</a></li><li><a href="http://www.boost.org/doc/libs/1_59_0/doc/html/boost_asio/overview/core/strands.html" target="_blank" rel="noopener">Strands: Use Threads Without Explicit Locking</a></li><li><a href="http://thisthread.blogspot.com/2012/04/post-on-asio-strand.html" target="_blank" rel="noopener">Post on ASIO strand</a></li><li><a href="https://stackoverflow.com/questions/39097644/how-strands-guarantee-correct-execution-of-pending-events-in-boost-asio" target="_blank" rel="noopener">How strands guarantee correct execution of pending events in boost.asio</a></li><li><a href="https://sourceforge.net/p/asio/mailman/message/19485596/" target="_blank" rel="noopener">asio C++ library</a><br><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3388.pdf" target="_blank" rel="noopener">Using Asio with C++11</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>asio</title>
      <link href="/posts/9d5b3554.html"/>
      <url>/posts/9d5b3554.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/" target="_blank" rel="noopener">Boost.Asio C++ 网络编程</a></li><li><a href="https://segmentfault.com/a/1190000007225464" target="_blank" rel="noopener">基于 Asio 的 C++ 网络编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/37590580" target="_blank" rel="noopener">C++网络编程之ASIO(一)</a></li><li><a href="http://think-async.com/Asio/asio-1.12.2/doc/" target="_blank" rel="noopener">asio文档</a></li><li><a href="http://think-async.com/Asio/boost_asio_1_12_2/doc/html/boost_asio.html" target="_blank" rel="noopener">boost.asio文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v8嵌入式开发--v8js篇</title>
      <link href="/posts/137637df.html"/>
      <url>/posts/137637df.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>v8js是一个特殊的php拓展, 其作用是将v8嵌入到php中, 使得用户可以在php中运行js代码. 同时, 经过作者的努力, 运行在php中的js可以无缝访问并php中的数据结构, 调用php內建的函数, 从而实现”1 + 1 &gt; 2”的目标. 本文将跟随作者的, 领略v8js的风采.</p><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>使用一个工具是了解这个工具的最好方式, 笔者将在这一节中介绍v8js拓展的功能及使用.</p><p>首先介绍一下v8js的提供的接口, v8js的接口如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V8Js</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* Constants */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> V8_VERSION = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FLAG_NONE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> FLAG_FORCE_ARRAY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> FLAG_PROPAGATE_PHP_EXCEPTIONS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes and starts V8 engine and returns new V8Js object with it's own V8 context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $object_name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $variables</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $extensions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bool $report_uncaught_exceptions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $snapshot_blob</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($object_name = <span class="string">"PHP"</span>, array $variables = [], array $extensions = [], $report_uncaught_exceptions = TRUE, $snapshot_blob = NULL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provide a function or method to be used to load required modules. This can be any valid PHP callable.</span></span><br><span class="line"><span class="comment">     * The loader function will receive the normalised module path and should return Javascript code to be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable $loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setModuleLoader</span><span class="params">(callable $loader)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provide a function or method to be used to normalise module paths. This can be any valid PHP callable.</span></span><br><span class="line"><span class="comment">     * This can be used in combination with setModuleLoader to influence normalisation of the module path (which</span></span><br><span class="line"><span class="comment">     * is normally done by V8Js itself but can be overriden this way).</span></span><br><span class="line"><span class="comment">     * The normaliser function will receive the base path of the current module (if any; otherwise an empty string)</span></span><br><span class="line"><span class="comment">     * and the literate string provided to the require method and should return an array of two strings (the new</span></span><br><span class="line"><span class="comment">     * module base path as well as the normalised name).  Both are joined by a '/' and then passed on to the</span></span><br><span class="line"><span class="comment">     * module loader (unless the module was cached before).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable $normaliser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setModuleNormaliser</span><span class="params">(callable $normaliser)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compiles and executes script in object's context with optional identifier string.</span></span><br><span class="line"><span class="comment">     * A time limit (milliseconds) and/or memory limit (bytes) can be provided to restrict execution. These options will throw a V8JsTimeLimitException or V8JsMemoryLimitException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $script</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $identifier</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $flags</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $time_limit in milliseconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $memory_limit in bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">executeString</span><span class="params">($script, $identifier = <span class="string">''</span>, $flags = V8Js::FLAG_NONE, $time_limit = <span class="number">0</span>, $memory_limit = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compiles a script in object's context with optional identifier string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $script</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $identifier</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> resource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">compileString</span><span class="params">($script, $identifier = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes a precompiled script in object's context.</span></span><br><span class="line"><span class="comment">     * A time limit (milliseconds) and/or memory limit (bytes) can be provided to restrict execution. These options will throw a V8JsTimeLimitException or V8JsMemoryLimitException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource $script</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $flags</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $time_limit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $memory_limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">executeScript</span><span class="params">($script, $flags = V8Js::FLAG_NONE, $time_limit = <span class="number">0</span> , $memory_limit = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the time limit (in milliseconds) for this V8Js object</span></span><br><span class="line"><span class="comment">     * works similar to the set_time_limit php</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setTimeLimit</span><span class="params">($limit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the memory limit (in bytes) for this V8Js object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setMemoryLimit</span><span class="params">($limit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the average object size (in bytes) for this V8Js object.</span></span><br><span class="line"><span class="comment">     * V8's "amount of external memory" is adjusted by this value for every exported object.  V8 triggers a garbage collection once this totals to 192 MB.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $average_object_size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setAverageObjectSize</span><span class="params">($average_object_size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns uncaught pending exception or null if there is no pending exception.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> V8JsScriptException|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPendingException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears the uncaught pending exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">clearPendingException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Static methods **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers persistent context independent global Javascript extension.</span></span><br><span class="line"><span class="comment">     * NOTE! These extensions exist until PHP is shutdown and they need to be registered before V8 is initialized.</span></span><br><span class="line"><span class="comment">     * For best performance V8 is initialized only once per process thus this call has to be done before any V8Js objects are created!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $extension_name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $dependencies</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bool $auto_enable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">registerExtension</span><span class="params">($extension_name, $code, array $dependencies, $auto_enable = FALSE)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns extensions successfully registered with V8Js::registerExtension().</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array|string[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a custom V8 heap snapshot with the provided JavaScript source embedded.</span></span><br><span class="line"><span class="comment">     * Snapshots are supported by V8 4.3.7 and higher.  For older versions of V8 this</span></span><br><span class="line"><span class="comment">     * extension doesn't provide this method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $embed_source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string|false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createSnapshot</span><span class="params">($embed_source)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V8JsScriptException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsFileName</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsLineNumber</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsStartColumn</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsEndColumn</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsSourceLine</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsTrace</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V8JsTimeLimitException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V8JsMemoryLimitException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面接口的注释可以知道, 使用v8js拓展执行js代码时, 基本流程是先创建一个V8Js类的对象, 然后执行成员函数executeString, 函数返回的结果即是js的执行结果.</p><p>V8js的成员函数<code>setTimeLimit</code>和<code>setMemoryLimit</code>函数用于设置js执行的时间限制和内存限制.</p><p>使用例子后续补充.</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p>接着讲一讲v8js拓展的架构设计. v8js模块包含了一个计时器线程, 计时任务双线队列, 全局变量结构体. 在全局变量结构体中存储了v8的platform. v8js模块中实现了一个名为V8Js的类, 在这个类的构造函数中, v8js会出现一个isolate对象, 并创建一个全局上下文. 那么v8js模块中, 一个V8Js类的对象包含一个独立的isolate对象. 整体架构如下图所示:</p><h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="js代码执行"><a href="#js代码执行" class="headerlink" title="js代码执行"></a>js代码执行</h2><p>v8的源码中提供了一个hello的代码, 如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化周边数据</span></span><br><span class="line">v8::V8::InitializeICUDefaultLocation(argv[<span class="number">0</span>]);</span><br><span class="line">v8::V8::InitializeExternalStartupData(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建platform</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化V8环境</span></span><br><span class="line">v8::V8::InitializePlatform(platform.<span class="built_in">get</span>());</span><br><span class="line">v8::V8::Initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造参数</span></span><br><span class="line">v8::Isolate::CreateParams create_params;</span><br><span class="line">create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建isolate对象(v8虚拟机实例)</span></span><br><span class="line">v8::Isolate* isolate = v8::Isolate::New(create_params);</span><br><span class="line">v8::<span class="function">Isolate::Scope <span class="title">isolate_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"><span class="function">v8::HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文</span></span><br><span class="line">v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate);</span><br><span class="line">v8::<span class="function">Context::Scope <span class="title">context_scope</span><span class="params">(context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将普通字符串转化为V8的字符串</span></span><br><span class="line">v8::Local&lt;v8::<span class="keyword">String</span>&gt; source = v8::<span class="keyword">String</span>::NewFromUtf8(isolate, <span class="string">"'Hello' + ', World!'"</span>,  v8::NewStringType::kNormal).ToLocalChecked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line">v8::Local&lt;v8::Script&gt; script = v8::Script::Compile(context, source).ToLocalChecked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果转化为普通字符串</span></span><br><span class="line">v8::<span class="function"><span class="keyword">String</span>::Utf8Value <span class="title">utf8</span><span class="params">(isolate, result)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *utf8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁isolate</span></span><br><span class="line">isolate-&gt;Dispose();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁V8环境和platform</span></span><br><span class="line">v8::V8::Dispose();</span><br><span class="line">v8::V8::ShutdownPlatform();</span><br><span class="line"><span class="keyword">delete</span> create_params.array_buffer_allocator;</span><br></pre></td></tr></table></figure><p>从demo可以看到, 运行一个js脚本需要的操作包括:</p><ul><li>创建platform</li><li>创建isolate</li><li>创建context</li><li>字符串编译成script</li><li>运行script</li><li>取出结果</li><li>销毁环境</li></ul><p>v8js拓展将platform创建放在了第一个V8Js类的构造函数中; isolate和context的创建放在了V8Js的构造函数. executeString中执行了编译和运行script的操作. 对象析构的时候销毁isolate对象. 模块退出的时候销毁platform等操作.</p><h2 id="內建函数实现"><a href="#內建函数实现" class="headerlink" title="內建函数实现"></a>內建函数实现</h2><p>在这个部分需要介绍一下v8的template机制以及v8各个元素之间的关系. 下面是v8的常用名词:</p><ul><li>platform 平台, 一个进程中可以有多个, 但是只有一个生效</li><li>isolate v8虚拟机, 可以存在多个, 一个isolate同一时间只允许一个线程访问</li><li>context 运行上下文, 可以有多个, 可以嵌套, 从属于isolate.</li><li>scope 作用域, isolate和context都有scope, 用于垃圾回收处理</li><li>template 模板, 用于创建函数和对象, 从属于isolate</li></ul><p>在v8中, 对象和函数从属于context, 而context在isolate的scope销毁时会被一同销毁, 那么这些对象和函数需要在context创建的时候被不停的创建, 为了省去这部分工作量, v8引入了template, 用于创建对象和函数.</p><p>內建函数的实现就是基于template实现的. 首先V8Js的的构造函数中会创建一个template对象, 然后再这个对象中添加functionTemplate对象, 而这些functionTemplate对象封装了內建函数. 在contenxt创建的时候, 将这个template对象作为实参传入, 那么创建出来的context就包含了內建函数.</p><p>template包含ObjectTemplate和FunctionTemplate两种, 前者创建对象, 后者创建函数. 如果用户想创建一个类呢? 由于js早期并不存在class关键词, 创建一个类的对象都是通过函数实现的. 所以创建一个类需要使用的是FunctionTemplate.</p><p>v8js拓展的內建函数的具体实现在文件”v8js_methods.cc”中, 在<code>v8js_register_methods</code>函数中将这些內建函数添加到template对象中. 这个函数在V8Js类的构造函数中被调用, 位置在contenxt被创建之前.</p><h2 id="commonjs模块实现"><a href="#commonjs模块实现" class="headerlink" title="commonjs模块实现"></a>commonjs模块实现</h2><p>首先讲一下什么是commonjs模块规范. “规范”认为, 每个文件是一个模块(module), 并拥有其自己的作用域. 在这个作用域内声明的变量和函数都是这个作用域私有的. 模块信息存储在module对象中, module提供exports对象用于暴露作用域内的函数/变量. 模块之间通过require函数加载其他的模块.</p><p>为了实现上面规范, 在每个文件的作用域内, 需要提前声明module, exports对象和require函数. 并且module和exports对象存在于模块中, 模块间的module和exports都不同. 参考上文中的template的功能, module和exports可以实现为两个ObjectTemplate, 并注册到主ObjectTemplate. 同样, require也可以类似实现. 这时基于主ObjectTemplate创建context, 并在这个context运行指定文件, 并提取exports, 即可暴露指定的接口(变量和函数).</p><p>考虑到重新创建context成本较大, v8的context支持基于老context创建新的context, 但是基于这种方式就无法使用到template了. nodejs的解决方案是, 创建一个函数, 在函数体中添加模块的代码, 将module/exports/require作为形参传入到. 例如, 模块的代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>nodejs编译编译这个代码之前, 将这个模块的代码处理为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value + x;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports.x = x;</span><br><span class="line">    <span class="built_in">module</span>.exports.addX = addX;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后, 创建module对象, exports对象, reuqire函数, 将这三个作为实参传入到生成的函数中去, 最后提取module和exports对象缓存起来. 当其他的模块reuqire这个模块时, 先查缓存, 命中缓存则直接返回exports对象.<br>v8js借鉴了nodejs的方式实现了一个commonjs模块.<br>由于reuqire一个模块时, 可以指定模块的相对路径, 这就要求reuqire在被调用时能够知道调用reuqire的文件的绝对路径. v8创建函数时支持给函数传递一个meta数据, v8js利用这个特性给require传递了路径数据. “v8js_commonjs.cc”中实现了一套相对路径推算绝对路径的代码, 使用c++17或者boost的话, 可以使用filesystem的canonical函数解决.</p><h2 id="超限功能实现"><a href="#超限功能实现" class="headerlink" title="超限功能实现"></a>超限功能实现</h2><p>前文提到v8js拓展包含一个计时器线程和计时任务队列, v8js依靠它们实现了超限功能.<br>V8Js类的对象在执行js脚本时, v8js会基于isolate/context/超时配置/内存限制创建一个超限任务, 并添加到计时任务队列中.<br>计时器线程会取出队列中的任务, 检查是否超时, 内存是否超限. 对超限的任务, 超时线程将终止任务运行. 在判断内存超限时, 计时器线程需要先解锁isolate, 然后获取堆统计信息, 如果超限就手工gc并终止当前任务.</p><h2 id="js中调用php数据实现"><a href="#js中调用php数据实现" class="headerlink" title="js中调用php数据实现"></a>js中调用php数据实现</h2><p>这部分略</p><h1 id="改进与优化"><a href="#改进与优化" class="headerlink" title="改进与优化"></a>改进与优化</h1><h2 id="isolate归属问题"><a href="#isolate归属问题" class="headerlink" title="isolate归属问题"></a>isolate归属问题</h2><p>在v8js中isolate是V8Js对象级别的, 事实上isolate和全局context的创建成本较大, 并不适合放在对象级别. 基于php单线程运行的特点, isolate和全局context可以存放在线程级别中. 每次执行脚本时, 基于全局context创建新的context.</p><h1 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h1><ul><li>学习了js脚本运行的流程</li><li>学习了v8中各个名词之间的关系</li><li>学习了多isolate的使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> v8 </tag>
            
            <tag> js </tag>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-addon-api使用文档</title>
      <link href="/posts/10f6a378.html"/>
      <url>/posts/10f6a378.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>“node-addon-api”是nodejs的”n-api”接口的c++封装, 通过提供c++对象模型和异常异常处理方式, 简化nodejs开发的成本.</p><p>“n-api”是nodejs为原生拓展提供的c语言风格ABI, 它独立于js运行环境, 旨在屏蔽js运行环境的差异, 让拓展能够运行在不同版本的nodejs下.</p><p>“node-addon-api”不作为nodejs的组件发布, 它只是基于nodejs的”n-api”, 这样, “node-addon-api”将于nodejs本身解耦, 基于”node-addon-api”的拓展运行在新nodejs环境时, 不需要重新编译.</p><p>值得注意的是, nodejs的其他接口, 例如<code>libuv</code>等, 并不包含在nodejs的拓展ABI内, 基于这些接口开发的nodejs拓展无法保证在多个版本的nodejs环境中运行. 由于”n-api”是nodejs 6.x之后才出现的, 因此这套ABI只支持nodejs6.x之后的版本.</p><p>当新的api被添加到n-api后, node-addon-api必须马上更新, 否则node-addon-api就无法使用这部分特性.</p><p>本文将数据结构, 异常处理, 与js交互等多个方面介绍node-addon-api.</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先是node-addon-api的数据结构, node-addon-api的数据结构是封装的n-api的, 我把它的数据结构分为两类, 一类是js中有直接对应类型的, 另一类是js中没有直接对应的类型, 但node-addon-api中出现的.</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th>js类型</th><th>c++类</th><th>说明</th></tr></thead><tbody><tr><td>string</td><td>String</td><td>字符串, 使用unicode存储</td></tr><tr><td>number</td><td>Number</td><td>数字, 使用浮点存储</td></tr><tr><td>boolean</td><td>Boolean</td><td>布尔值</td></tr><tr><td>bigInt</td><td>BigInt</td><td>大整形, 新引入, 使用uint64数组存储</td></tr><tr><td>object</td><td>Object</td><td>对象</td></tr><tr><td>symbol</td><td>Symbol</td><td>符号</td></tr><tr><td>Buffer</td><td>Buffer</td><td>二进制类型, 不受gc管理</td></tr><tr><td>function</td><td>Function</td><td>函数类型</td></tr><tr><td>arrayBuffer</td><td>ArrayBuffer</td><td>buffer数组类型</td></tr><tr><td>typedArray</td><td>TypedArray</td><td>类型数组</td></tr><tr><td>DataView</td><td>DataView</td><td>视图</td></tr><tr><td>promises</td><td>Promises</td></tr></tbody></table><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><table><thead><tr><th>特殊类型</th><th>说明</th></tr></thead><tbody><tr><td>Name</td><td>特殊的类型, 可以用来作为类的属性名, 支持字符串和symbol</td></tr><tr><td>Env</td><td>特殊结构, 包含了当前请求的运行环境</td></tr><tr><td>Value</td><td>js类型的c++表现类型, js类型的基类</td></tr><tr><td>CallbackInfo</td><td>特殊结构, 包含函数参数列表和Env对象, 常出现在c++实现的js函数参数表中, , 由nodejs环境生成传递给自定义函数.</td></tr><tr><td>Reference</td><td>特殊引用类型, 类似于c++中的shared_ptr, 创建时不添加计数器. 当计数器为0时, 不负责删除数据, 使用垃圾回收机制回收数据.</td></tr><tr><td>External</td><td>用来包装c++数据的结构, 方便用户管理自定义结构, 这个类提供自定义清理函数接口, 可以让用户制定清理方法.</td></tr><tr><td>ObjectReference</td><td>对象引用类型, 是Reference的子类, 包含引用对象和一个计数器, 相当于shared_ptr.</td></tr><tr><td>PropertyDescriptor</td><td>js对象的属性描述, 可以是函数/变量/访问控制等.</td></tr><tr><td>FunctionReference</td><td></td></tr><tr><td>ObjectWrap</td><td></td></tr><tr><td>ClassPropertyDescriptor</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><h2 id="对象及引用"><a href="#对象及引用" class="headerlink" title="对象及引用"></a>对象及引用</h2><h1 id="与js交互"><a href="#与js交互" class="headerlink" title="与js交互"></a>与js交互</h1><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><h2 id="js函数调用"><a href="#js函数调用" class="headerlink" title="js函数调用"></a>js函数调用</h2><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="额外类型"><a href="#额外类型" class="headerlink" title="额外类型"></a>额外类型</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h1 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h1><h1 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="对象生命周期管理"><a href="#对象生命周期管理" class="headerlink" title="对象生命周期管理"></a>对象生命周期管理</h2><h1 id="异步操作-1"><a href="#异步操作-1" class="headerlink" title="异步操作"></a>异步操作</h1><h1 id="promises"><a href="#promises" class="headerlink" title="promises"></a>promises</h1><h1 id="版本管理-1"><a href="#版本管理-1" class="headerlink" title="版本管理"></a>版本管理</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>node-addon-api-example</title>
      <link href="/posts/ebe76269.html"/>
      <url>/posts/ebe76269.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v8_learn</title>
      <link href="/posts/c7657d28.html"/>
      <url>/posts/c7657d28.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>graphviz_learn</title>
      <link href="/posts/3a17fc38.html"/>
      <url>/posts/3a17fc38.html</url>
      
        <content type="html"><![CDATA[<p>参考: <a href="http://blog.jobbole.com/94472/" target="_blank" rel="noopener">graphviz教程</a></p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>boost_learn</title>
      <link href="/posts/a9053cb5.html"/>
      <url>/posts/a9053cb5.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nodejs_ext</title>
      <link href="/posts/58b03904.html"/>
      <url>/posts/58b03904.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日志代码收敛(log4cpp/glog)</title>
      <link href="/posts/b270d3a9.html"/>
      <url>/posts/b270d3a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍某项目中日志代码的收敛工作.<br>这个项目由多个模块组成, 各个模块使用的日志系统不同, 有的模块使用log4cpp, 有的模块使用glog.<br>这给项目的管理带来了一定的困难, 因此需要对整个项目进行改造, 统一日志系统.</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="日志库"><a href="#日志库" class="headerlink" title="日志库"></a>日志库</h2><p>目前c++常用并且开源的日志库包括:</p><ul><li>log4cxx</li><li>log4cpp</li><li>log4cplus</li><li>glog</li><li>g3log</li><li>boost.log</li><li>boost.log v2</li></ul><h3 id="log4cxx"><a href="#log4cxx" class="headerlink" title="log4cxx"></a>log4cxx</h3><p>log4cxx是apache的log4j的官方c++实现, 架构类似于log4j, 使用跟log4j兼容的配置文件.<br>这个项目已经不再更新.<br>在centos的软件库中包含了log4cxx的开发包(log4cxx-devel).</p><h3 id="log4cpp"><a href="#log4cpp" class="headerlink" title="log4cpp"></a>log4cpp</h3><p>log4cpp是log4j的一个非官方实现, 与log4j类似的架构, 并且兼容log4j的配置文件.<br>这个项目最新更新的时间是2017, 并且已经一年没更新了.<br>在centos的软件库中包含了log4cpp的开发包(log4cpp-devel).</p><h3 id="log4cplus"><a href="#log4cplus" class="headerlink" title="log4cplus"></a>log4cplus</h3><p>log4cplus是log4j的另一个非官方实现, 与log4j类似的架构, 并且兼容log4j的配置文件.<br>这个项目一直在更新, 并且已经发布2.0版本.<br>在centos的软件库中包含了log4cplus的开发包(log4cplus)</p><h3 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h3><p>glog是谷歌开源的日志系统, 以简单著称, 支持的功能包括:</p><p>1， 参数设置，以命令行参数的方式设置标志参数来控制日志记录行为；<br>2， 严重性分级，根据日志严重性分级记录日志；<br>3， 可有条件地记录日志信息；<br>4， 条件中止程序。丰富的条件判定宏，可预设程序终止条件；<br>5， 异常信号处理。程序异常情况，可自定义异常处理过程；<br>6， 支持debug功能。可只用于debug模式；<br>7， 自定义日志信息；<br>8， 线程安全日志记录方式；<br>9， 系统级日志记录；<br>10， google perror风格日志信息；<br>11， 精简日志字符串信息。</p><h3 id="g3log"><a href="#g3log" class="headerlink" title="g3log"></a>g3log</h3><p>glog不支持异步日志, 并且性能较差. 于是有开发者基于glog开发了支持异步日志的新日志系统, 命名为g3log.</p><h3 id="boost-log-v1"><a href="#boost-log-v1" class="headerlink" title="boost.log v1"></a>boost.log v1</h3><p>这个日志系统出现较早, 但是一直没有合入到boost套装中.<br>用户如果要使用这个库, 则需要单独编译.</p><h3 id="boost-log-v2"><a href="#boost-log-v2" class="headerlink" title="boost.log v2"></a>boost.log v2</h3><p>从boost 1.54开始, boost.log v2加入boost库, 但是目前centos7的boost版本是1.53.<br>boost将日志系统进行分层, 类似于log4j, 并且同时支持同步和异步日志.</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>目前项目的A模块使用log4cpp作为日志</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spinlock</title>
      <link href="/posts/4a74a9d.html"/>
      <url>/posts/4a74a9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将介绍自旋锁的原理, 并封装linux提供的自旋锁, 最后介绍boost提供的自旋锁.</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分（对于单处理器来说，防止中断处理中的并发可简单采用关闭中断的方式，即在标志寄存器中关闭/打开中断标志位，不需要自旋锁）。</p><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><p>跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题：<br>死锁。试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入死循环。<br>过多占用cpu资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会。<br>由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。<br>上面简要介绍了自旋锁的基本原理，以下将给出具体的例子，进一步阐释自旋锁在实际系统中的应用。上面我们已经讲过自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，下面我们就以SMP为例，来说明为什么要使用自旋锁，以及自旋锁实现的基本算法。</p><p>通俗的讲, 自旋锁是一种不放弃CPU资源的锁.</p><h1 id="自旋锁使用"><a href="#自旋锁使用" class="headerlink" title="自旋锁使用"></a>自旋锁使用</h1><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SpinLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        pthread_spin_lock(&amp;spinlock_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        pthread_spin_unlock(&amp;spinlock_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pthread_spinlock_t spinlock_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SpinLockGuard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SpinLockGuard</span>(<span class="params">SpinLock &amp;spinlock</span>): <span class="title">spinlock_</span>(<span class="params">spinlock</span>)</span> &#123;</span><br><span class="line">        spinlock_.<span class="keyword">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SpinLockGuard() &#123;</span><br><span class="line">        spinlock_.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SpinLock <span class="keyword">lock</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SpinLockGuard <span class="title">guard</span>(<span class="params"><span class="keyword">lock</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="boost版本"><a href="#boost版本" class="headerlink" title="boost版本"></a>boost版本</h1><p>boost中实现了自旋锁功能, 但是没有显示提供, 自旋锁的位置在<code>boost/smarty_ptr/detail/spinlock.hpp</code><br>lockguard在&lt;boost/thread/thread_guard.hpp&gt;.</p><p>使用方法如下:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using SpinLock = boost::detail::spinlock;</span><br><span class="line">using SpinLockGuard = boost::lock_guard<span class="params">&lt;SpinLock&gt;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SpinLock lock;</span><br><span class="line">&#123;</span><br><span class="line">    SpinLockGuard guard(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> boost </tag>
            
            <tag> spin lock </tag>
            
            <tag> 自旋锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unite.vim插件使用及配置</title>
      <link href="/posts/b0d02bc6.html"/>
      <url>/posts/b0d02bc6.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要介绍unite.vim的使用与配置.<br>unite.vim是Shougo开发的一款插件, 确切的说, unite就像vim插件里面的vim.<br>这个插件功能繁多, 配置项目较多, 一定程度上怎么了用户的学习成本, 本文将详细介绍这个工具的使用与配置.</p><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>本文介绍的unite.vim的功能包括unite.vim集成的功能以及第三方插件的功能.<br>unite.vim由于其丰富的功能以及高扩展性, 已经衍生出了多款基于unite.vim的插件.</p><p>unite.vim集成的功能包括:</p><ul><li>bookmark 书签功能</li><li>buffer, buffer_tab buffer浏览功能</li><li>change 列举变动</li><li>command ex命令</li><li>directory, directory/new, directory_mru 目录相关功能</li><li>fie, file/new, file_point, file_rec 文件相关功能</li><li>function 函数相关功能</li><li>grep</li><li>history</li><li>jump, jump_point 跳转相关功能</li><li>launcher</li><li>line, line/fast 行号相关功能</li><li>mapping</li><li>menu</li><li>neocomplete</li><li>output</li><li>process</li><li>resume</li><li>runtimepath</li><li>source</li><li>tab</li><li>vimgrep</li><li>window</li></ul><p>基于unite.vim的插件包括:</p><ul><li>unite-help</li><li>unite-tag</li><li>unite-outline</li><li>unite-colorscheme</li><li>unite-font</li><li>unite-locate</li><li>unite-everything</li><li>unite-mark</li><li>unite-alias</li><li>unite-script</li><li>unite-git_grep</li><li>unite-remotefile</li><li>unite-neco</li><li>unite-rake</li><li>unite-history</li><li>unite-qflist</li><li>unite-gem</li><li>unite-qf</li><li>unite-session</li><li>unite-svn</li><li>unite-rails</li><li>unite-grails</li><li>unite-cake</li><li>unite-zf, unite-sf2</li><li>unite-ack</li><li>unite-launch</li><li>unite-transparency</li><li>quicklearn</li><li>vim_hacks</li><li>haskellimport</li><li>unite-equery</li><li>unite-file-vcs</li><li>unite-radio.vim</li><li>unite-gist</li><li>vim-unite-id</li><li>unite-ref</li></ul><h1 id="buffer功能介绍与配置"><a href="#buffer功能介绍与配置" class="headerlink" title="buffer功能介绍与配置"></a>buffer功能介绍与配置</h1><p>vim中的buffer类似于ide中已经打开的文件, vim将已经打开的文件保存到buffer中, 方便用户去使用.<br>unite.vim内置buffer功能, 使用<code>:Unite source</code>命令可以看到.<br>unite.vim提供的buffer功能包括:</p><ul><li>buffer</li><li>buffer_tab</li></ul><p>其中执行<code>:Unite buffer</code>命令后, 会在新的tab中显示buffer列表, 而执行<code>:Unite buffer_tab</code>后会在当前tab中显示buffer.<br>unite为buffer选择提供了即时搜索的功能, 用户可以搜索关键词, 然后unite查找buffer对应的文件, 然后进行排序. unite查找的内容仅限于路径和文件名.</p><p>vim中有类似功能的插件包括, MinBufExplorer和bufexporer插件.</p><p>bufexporer插件使用简单, 它提供三个命令分别是<code>\be</code>(打开历史文件列表), <code>\bv</code>(水平创建一个tab显示buffer信息), <code>\bs</code>(垂直创建一个tab显示buffer信息).<br>这个插件不需要配置, 加载即可使用. 比较麻烦的是, 快捷键比较逆天, 而且不支持buffer的搜索.</p><p>MinBufExporer会开一个狭小的tab显示buffer列表信息.<br>使用minBufExporer方面, minbufexporer跟bufexporer一样, 不需要配置, 可以直接使用.<br>在minBufExporer使用<code>:bn</code>(下一个buffer), <code>:np</code>(上一个buf), <code>:b”num”</code>,<br><code>:MiniBufExporer</code>(打开tab, 并显示buffer信息), <code>:CMiniBufExporer</code>(关闭buffer的tab).</p><p>与这两个插件相比, unite buffer显得无比强大好用.</p><h1 id="文件查找功能介绍与配置"><a href="#文件查找功能介绍与配置" class="headerlink" title="文件查找功能介绍与配置"></a>文件查找功能介绍与配置</h1><h1 id="outline功能介绍与配置"><a href="#outline功能介绍与配置" class="headerlink" title="outline功能介绍与配置"></a>outline功能介绍与配置</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> unite.vim </tag>
            
            <tag> vim插件 </tag>
            
            <tag> vim配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaf源码阅读</title>
      <link href="/posts/c1026c5e.html"/>
      <url>/posts/c1026c5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将分别从接口层和实现层解读yaf框架.</p><h1 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>yaf是一个使用c实现的高性能框架. 它以php拓展的形式实现整个php框架.</p><p>它的优点包括:</p><ol><li>用C语言开发的PHP框架, 相比原生的PHP, 几乎不会带来额外的性能开销.</li><li>所有的框架类, 不需要编译, 在PHP启动的时候加载, 并常驻内存.</li><li>更短的内存周转周期, 提高内存利用率, 降低内存占用率.</li><li>灵巧的自动加载. 支持全局和局部两种加载规则, 方便类库共享.</li><li>高性能的视图引擎.</li><li>高度灵活可扩展的框架, 支持自定义视图引擎, 支持插件, 支持自定义路由等等.</li><li>内建多种路由, 可以兼容目前常见的各种路由协议.</li><li>强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失.</li><li>在框架本身,对危险的操作习惯做了禁止.</li><li>更快的执行速度, 更少的内存占用.</li></ol><h2 id="框架执行"><a href="#框架执行" class="headerlink" title="框架执行"></a>框架执行</h2><p>整个框架分为应用程序组件集和其他基础组件集. 在应用程序组件集中包含了, 插件, 分发器, 路由器, 控制器, 启动器等. 基础组件包括, session组件, 注册表组件, 自动加载组件, 配置组件.</p><p>yaf框架包含多个层次, 分别是:</p><ul><li>Application 应用程序, 一个服务作为一个应用程序</li><li>Module 模块, 一个服务包含多个模块</li><li>Controller 控制器, 一个模块包含多个控制器</li><li>Action 动作, 一个控制器包含多个动作</li></ul><p>yaf是传统的php框架, 使用传统的执行流程. 这类执行流程无法上下文复用, 每处理一个请求就要初始化一次框架.</p><p>处理用户请求时, yaf框架先创建应用程序(Application类对象), 应用程序类创建启动器(Bootstrap类对象), 启动器执行分发器加载, 插件加载等操作. 然后应用程序将请求封装成请求对象(Request类对象), 将请求对象交付给分发器, 分发器根据路由器中的路由规则, 获得对应的处理对象. 路由器根据URI信息, 查询路由规则, 找到匹配的路由规则, 根据路由规则获得相应的处理器(Controller类对象), 并将其返回给分发器. 分发器执行处理器, 将处理结果封装成相应对象(Response对象)返回给应用程序. 应用程序将响应对象返回给用户. 框架的执行流程如图所示:</p><p><img src="/images/yaf_sequence.png" alt="yaf执行流程图"></p><h2 id="自动加载组件"><a href="#自动加载组件" class="headerlink" title="自动加载组件"></a>自动加载组件</h2><p>yaf框架为了兼容老版本的php, 提供两种自动加载的策略, 分别是基于下划线的自动加载方案和名字空间加载方案. yaf的加载方案在配置文件中指定.</p><p>yaf中库的分为本地库和全局库, 全局库作用于整个应用程序, 本地库只作用于当前模块(Module), 当当前应用程序中只包含一个模块时, 全局库和本地库的区别只是位置的不同罢了.</p><h3 id="下划线自动加载方案"><a href="#下划线自动加载方案" class="headerlink" title="下划线自动加载方案"></a>下划线自动加载方案</h3><p>这种自动加载方案会对需要加载的类的类名进行处理, 将类名中的下划线(<code>_</code>)替换为替换为斜线(<code>/</code>), 生成类路径, 然后进行库文件查找. 库查找时, 先获得本地库的路径, 接着融合本地库路径和类目录, 得到类文件的绝对路径, 然后判断这个文件是否存在, 如果存在, 则进行加载, 否则进行全局库查找.</p><p>执行的流程如下:</p><div id="flowchart-0" class="flow-chart"></div><h2 id="路由组件"><a href="#路由组件" class="headerlink" title="路由组件"></a>路由组件</h2><h2 id="分发器组件"><a href="#分发器组件" class="headerlink" title="分发器组件"></a>分发器组件</h2><h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><p>从图中可以看到, 整个框架的核心是这个分发器. yaf框架针对分发的执行流程, 在各个执行片段添加了钩子, 并通过这些钩子制作了插件机制.</p><p>yaf的钩子包括:</p><ul><li>routerStartup 在查询路由规则之前执行</li><li>routerShutdown 在查询完路由规则之前执行</li><li>dispatchLoopStart 在分发流程开始前执行</li><li>preDispatch 在分发操作之前执行</li><li>postDispatch 在分发操作完毕执行</li><li>dispatchLoopShutdown 在分发流程结束后执行</li></ul><h1 id="实现层"><a href="#实现层" class="headerlink" title="实现层"></a>实现层</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">begin=>start: 开始end=>end: 结束get_class_name=>operation: 获得类名process=>operation: 下划线替换为斜线,生成类路径get_global_lib=>operation: 获得全局库绝对路径get_local_lib=>operation: 获得本地库路径merge_global=>operation: 合并全局库路径和类路径, 生成文件绝对路径merge_local=>operation: 合并本地库路径和类路径, 生成文件绝对路径judge_global=>condition: 判断文件是否存在judge_local=>condition: 判断文件是否存在load_error=>operation: 加载失败load_global=>operation: 加载文件load_local=>operation: 加载文件begin->get_class_name->process->get_local_lib->merge_local->judge_localjudge_local(yes)->load_local->endjudge_local(no)->get_global_lib->merge_global->judge_globaljudge_global(yes)->load_global->endjudge_global(no)->load_error->end</textarea><textarea id="flowchart-0-options" style="display:none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script></p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> yaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建及优化</title>
      <link href="/posts/121dda.html"/>
      <url>/posts/121dda.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将介绍基于hexo博客搭建的过程, 包括, 博客搭建, 主题选择, 插件安装以及插件使用等.</p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>hexo博客是纯静态的博客, 用户通过编写markdown文件完成博客编写, 然后使用hexo提供的构建工具将md文件生成静态页面.<br>hexo使用主题模板将md渲染成静态html页面. 最后, 用户将这些静态页面部署到服务器中, 完成整个博客的部署.</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><p>建议主题:</p><ul><li>next 简约好看</li></ul><h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><p>推荐插件:</p><ul><li>hexo-abbrlink 生成固定链接, 降低url长度</li><li>hexo-all-minifier 压缩html/css/js, js打包到一个文件的功能有问题.</li><li>hexo-deployer-git 自动化部署</li><li>hexo-filter-flowchart markdown支持流程图</li><li>hexo-filter-optimize 将js打包成一个文件, 将main.css内联到html中</li><li>hexo-filter-plantuml markdown支持uml</li><li>hexo-filter-sequence markdown支持时序图</li><li>hexo-generator-baidu-sitemap 生成百度的sitemap</li><li>hexo-generator-search 支持即时搜索</li><li>hexo-generator-sitemap 生成sitemap</li><li>hexo-offline 缓存支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 优化 </tag>
            
            <tag> 博客搭建 </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用cmake构建yaf框架</title>
      <link href="/posts/4d3b3d24.html"/>
      <url>/posts/4d3b3d24.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍使用cmake构建yaf框架</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="yaf"><a href="#yaf" class="headerlink" title="yaf"></a>yaf</h2><p>yaf是一个使用c语言实现的php框架, 作为php的拓展加载到php中, 具有较高的性能.<br>php的拓展使用phpize构建, 这类构建工具不友好, 本文将改用更加友好的cmake工具.</p><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>cmake是一款较为友好的构建工具, 其拥有自己的配置语法.<br>cmake工具较为友好的一个方面是, 多种集成开发环境对其支持, 包括:</p><ul><li>CLion</li><li>codeblocks</li><li>等等</li></ul><p>比较重要的一点是, CLion使用cmake构建项目, 所以CLion只对能够使用cmake构建的项目友好.<br>这也是phpize不太友好的一点.</p><h1 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h1><p>cmake将CMakeLists.txt作为项目管理文件, 改造的过程变为编写CMakeLists.txt的过程.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>改造之前需要准备的工具包括:</p><ul><li>安装cmake</li><li>安装php开发包</li><li>生成config.h</li></ul><p>执行<code>yum install cmake</code>命令完成cmake的安装.<br>执行<code>yum install php-devel</code>命令完成php开发包的安装</p><p>使用phpize进行构建过程中, 构架工具会生成一个config.h的文件, 这个文件定义了一些重要的宏.<br>为了降低CMakeLists.txt的编写成本, 本文将通过phpize工具生成config.h, 然后直接使用config.h.</p><h2 id="编写CMakeLists-txt"><a href="#编写CMakeLists-txt" class="headerlink" title="编写CMakeLists.txt"></a>编写CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(reading_yaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找php-config目录</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">DEFINED</span> PHP_CONFIG_DIR)</span><br><span class="line">    <span class="keyword">set</span>(PHP_CONFIG_DIR <span class="string">"$&#123;PHP_CONFIG_DIR&#125;/"</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">set</span>(PHP_CONFIG_DIR <span class="string">""</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取include目录</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --<span class="keyword">include</span>-dir</span><br><span class="line">        OUTPUT_VARIABLE PHP_INCLUDE_DIR</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 读取链接库</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --libs</span><br><span class="line">        OUTPUT_VARIABLE PHP_LIBS</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 读取链接参数</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --ldflags</span><br><span class="line">        OUTPUT_VARIABLE PHP_LDFLAGS</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 获取插件存放目录</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --extension-dir</span><br><span class="line">        <span class="comment">#    RESULT_VARIABLE PHP_EXTDIR</span></span><br><span class="line">        OUTPUT_VARIABLE PHP_EXTDIR</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(</span><br><span class="line">        -DZEND_ENABLE_STATIC_TSRMLS_CACHE=<span class="number">1</span></span><br><span class="line">        -DHAVE_CONFIG_H</span><br><span class="line">        -DPHP_ATOM_INC</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 包含目录, 保持与php-config --includes的结果一致</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">        BEFORE</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span></span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/Zend</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/main</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/TSRM</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/ext</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/ext/date/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加include目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(.)</span><br><span class="line"><span class="keyword">include_directories</span>(configs)</span><br><span class="line"><span class="keyword">include_directories</span>(requests)</span><br><span class="line"><span class="keyword">include_directories</span>(responses)</span><br><span class="line"><span class="keyword">include_directories</span>(routes)</span><br><span class="line"><span class="keyword">include_directories</span>(views)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(configs SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(requests SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(responses SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(routes SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(views SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加构建目标</span></span><br><span class="line"><span class="keyword">add_library</span>(yaf SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加安装目录</span></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">        TARGETS yaf</span><br><span class="line">        LIBRARY DESTINATION <span class="variable">$&#123;PHP_EXTDIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置构建产物的命名, 包括</span></span><br><span class="line"><span class="comment"># - 去掉"lib"前缀</span></span><br><span class="line"><span class="comment"># - 统一后缀为".so"</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(</span><br><span class="line">        yaf PROPERTIES</span><br><span class="line">        PREFIX <span class="string">""</span></span><br><span class="line">        SUFFIX <span class="string">".so"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      
      <categories>
          
          <category> php-devel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php-devel </tag>
            
            <tag> php </tag>
            
            <tag> cmake </tag>
            
            <tag> yaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境部署</title>
      <link href="/posts/8c50c265.html"/>
      <url>/posts/8c50c265.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cpp-devel </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
